{
  "__getattr__": {
    "name": "__getattr__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "turn_console_off": {
    "name": "turn_console_off",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/__init__.py"
  },
  "turn_console_on": {
    "name": "turn_console_on",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/__init__.py"
  },
  "trace": {
    "name": "trace",
    "docstring": "Wraps trace message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "debug": {
    "name": "debug",
    "docstring": "Wraps debug message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "from_scale_encoding": {
    "name": "from_scale_encoding",
    "docstring": "Decodes input_ data from SCALE encoding based on the specified type name and modifiers.\n\nArgs:\n    input_ (Union[List[int], bytes, ScaleBytes]): The input_ data to decode.\n    type_name (ChainDataType): The type of data being decoded.\n    is_vec (bool, optional): Whether the data is a vector of the specified type. Default is ``False``.\n    is_option (bool, optional): Whether the data is an optional value of the specified type. Default is ``False``.\n\nReturns:\n    Optional[Dict]: The decoded data as a dictionary, or ``None`` if the decoding fails.",
    "parameters": [
      {
        "name": "input_",
        "type": "Union[List[int], bytes, ScaleBytes]"
      },
      {
        "name": "type_name",
        "type": "ChainDataType"
      },
      {
        "name": "is_vec",
        "type": "bool"
      },
      {
        "name": "is_option",
        "type": "bool"
      }
    ],
    "returns": "Optional[Dict]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "from_scale_encoding_using_type_string": {
    "name": "from_scale_encoding_using_type_string",
    "docstring": null,
    "parameters": [
      {
        "name": "input_",
        "type": "Union[List[int], bytes, ScaleBytes]"
      },
      {
        "name": "type_string",
        "type": "str"
      }
    ],
    "returns": "Optional[Dict]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "is_serving": {
    "name": "is_serving",
    "docstring": "True if the endpoint is serving.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "ip_str": {
    "name": "ip_str",
    "docstring": "Return the whole IP as string",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "__eq__": {
    "name": "__eq__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__str__": {
    "name": "__str__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "__repr__": {
    "name": "__repr__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "to_string": {
    "name": "to_string",
    "docstring": "Provides a human-readable representation of the AxonInfo for this Axon.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "from_string": {
    "name": "from_string",
    "docstring": "Creates an AxonInfo object from its string representation using JSON.\n\nArgs:\n    json_string (str): The JSON string representation of the AxonInfo object.\n\nReturns:\n    AxonInfo: An instance of AxonInfo created from the JSON string. If decoding fails, returns a default AxonInfo object with default values.\n\nRaises:\n    json.JSONDecodeError: If there is an error in decoding the JSON string.\n    TypeError: If there is a type error when creating the AxonInfo object.\n    ValueError: If there is a value error when creating the AxonInfo object.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "json_string",
        "type": "str"
      }
    ],
    "returns": "'AxonInfo'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "from_neuron_info": {
    "name": "from_neuron_info",
    "docstring": "Converts a dictionary to an AxonInfo object.\n\nArgs:\n    neuron_info (dict): A dictionary containing the neuron information.\n\nReturns:\n    instance (AxonInfo): An instance of AxonInfo created from the dictionary.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "neuron_info",
        "type": "dict"
      }
    ],
    "returns": "'AxonInfo'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "to_parameter_dict": {
    "name": "to_parameter_dict",
    "docstring": "Returns a torch tensor or dict of the subnet IP info.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[dict[str, Union[str, int]], 'torch.nn.ParameterDict']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "from_parameter_dict": {
    "name": "from_parameter_dict",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "parameter_dict",
        "type": "Union[dict[str, Any], 'torch.nn.ParameterDict']"
      }
    ],
    "returns": "'IPInfo'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "fix_decoded_values": {
    "name": "fix_decoded_values",
    "docstring": "Fixes the decoded values.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "decoded",
        "type": "Any"
      }
    ],
    "returns": "'ScheduledColdkeySwapInfo'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "from_vec_u8": {
    "name": "from_vec_u8",
    "docstring": "Returns a ScheduledColdkeySwapInfo object from a ``vec_u8``.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "vec_u8",
        "type": "List[int]"
      }
    ],
    "returns": "Optional['ScheduledColdkeySwapInfo']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "list_from_vec_u8": {
    "name": "list_from_vec_u8",
    "docstring": "Returns a list of ScheduledColdkeySwapInfo objects from a ``vec_u8``.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "vec_u8",
        "type": "List[int]"
      }
    ],
    "returns": "List['ScheduledColdkeySwapInfo']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "get_null_neuron": {
    "name": "get_null_neuron",
    "docstring": null,
    "parameters": [],
    "returns": "'NeuronInfoLite'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "from_weights_bonds_and_neuron_lite": {
    "name": "from_weights_bonds_and_neuron_lite",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "neuron_lite",
        "type": "'NeuronInfoLite'"
      },
      {
        "name": "weights_as_dict",
        "type": "Dict[int, List[Tuple[int, int]]]"
      },
      {
        "name": "bonds_as_dict",
        "type": "Dict[int, List[Tuple[int, int]]]"
      }
    ],
    "returns": "'NeuronInfo'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "delegated_list_from_vec_u8": {
    "name": "delegated_list_from_vec_u8",
    "docstring": "Returns a list of Tuples of DelegateInfo objects, and Balance, from a ``vec_u8``.\n\nThis is the list of delegates that the user has delegated to, and the amount of stake delegated.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "vec_u8",
        "type": "List[int]"
      }
    ],
    "returns": "List[Tuple['DelegateInfo', Balance]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "list_of_tuple_from_vec_u8": {
    "name": "list_of_tuple_from_vec_u8",
    "docstring": "Returns a list of StakeInfo objects from a ``vec_u8``.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "vec_u8",
        "type": "List[int]"
      }
    ],
    "returns": "Dict[str, List['StakeInfo']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "encode": {
    "name": "encode",
    "docstring": "Returns a dictionary of the IPInfo object that can be encoded.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Dict[str, Any]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "decode_account_id_list": {
    "name": "decode_account_id_list",
    "docstring": "Decodes a list of AccountIds from vec_u8.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "vec_u8",
        "type": "List[int]"
      }
    ],
    "returns": "Optional[List[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/chain_data.py"
  },
  "__init__": {
    "name": "__init__",
    "docstring": "Init bittensor wallet object containing a hot and coldkey.\nArgs:\n    _mock (required=True, default=False):\n        If true creates a mock wallet with random keys.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "get_save_dir": {
    "name": "get_save_dir",
    "docstring": "Return directory path from ``network`` and ``netuid``.\n\nArgs:\n    network (str): Network name.\n    netuid (int): Network UID.\n\nReturns:\n    str: Directory path.",
    "parameters": [
      {
        "name": "network",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "latest_block_path": {
    "name": "latest_block_path",
    "docstring": "Get the latest block path from the directory.\n\nArgs:\n    dir_path (str): Directory path.\n\nReturns:\n    str: Latest block path.",
    "parameters": [
      {
        "name": "dir_path",
        "type": "str"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "S": {
    "name": "S",
    "docstring": "Represents the stake of each neuron in the Bittensor network. Stake is an important concept in the\nBittensor ecosystem, signifying the amount of network weight (or \u201cstake\u201d) each neuron holds,\nrepresented on a digital ledger. The stake influences a neuron's ability to contribute to and benefit\nfrom the network, playing a crucial role in the distribution of incentives and decision-making processes.\n\nReturns:\n    NDArray: A tensor representing the stake of each neuron in the network. Higher values signify a greater stake held by the respective neuron.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "R": {
    "name": "R",
    "docstring": "Contains the ranks of neurons in the Bittensor network. Ranks are determined by the network based\non each neuron's performance and contributions. Higher ranks typically indicate a greater level of\ncontribution or performance by a neuron. These ranks are crucial in determining the distribution of\nincentives within the network, with higher-ranked neurons receiving more incentive.\n\nReturns:\n    NDArray: A tensor where each element represents the rank of a neuron. Higher values indicate higher ranks within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "I": {
    "name": "I",
    "docstring": "Incentive values of neurons represent the rewards they receive for their contributions to the network.\nThe Bittensor network employs an incentive mechanism that rewards neurons based on their\ninformational value, stake, and consensus with other peers. This ensures that the most valuable and\ntrusted contributions are incentivized.\n\nReturns:\n    NDArray: A tensor of incentive values, indicating the rewards or benefits accrued by each neuron based on their contributions and network consensus.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "E": {
    "name": "E",
    "docstring": "Denotes the emission values of neurons in the Bittensor network. Emissions refer to the distribution or\nrelease of rewards (often in the form of cryptocurrency) to neurons, typically based on their stake and\nperformance. This mechanism is central to the network's incentive model, ensuring that active and\ncontributing neurons are appropriately rewarded.\n\nReturns:\n    NDArray: A tensor where each element represents the emission value for a neuron, indicating the amount of reward distributed to that neuron.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "C": {
    "name": "C",
    "docstring": "Represents the consensus values of neurons in the Bittensor network. Consensus is a measure of how\nmuch a neuron's contributions are trusted and agreed upon by the majority of the network. It is\ncalculated based on a staked weighted trust system, where the network leverages the collective\njudgment of all participating peers. Higher consensus values indicate that a neuron's contributions\nare more widely trusted and valued across the network.\n\nReturns:\n    NDArray: A tensor of consensus values, where each element reflects the level of trust and agreement a neuron has achieved within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "T": {
    "name": "T",
    "docstring": "Represents the trust values assigned to each neuron in the Bittensor network. Trust is a key metric that\nreflects the reliability and reputation of a neuron based on its past behavior and contributions. It is\nan essential aspect of the network's functioning, influencing decision-making processes and interactions\nbetween neurons.\n\nThe trust matrix is inferred from the network's inter-peer weights, indicating the level of trust each neuron\nhas in others. A higher value in the trust matrix suggests a stronger trust relationship between neurons.\n\nReturns:\n    NDArray: A tensor of trust values, where each element represents the trust level of a neuron. Higher values denote a higher level of trust within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "Tv": {
    "name": "Tv",
    "docstring": "Contains the validator trust values of neurons in the Bittensor network. Validator trust is specifically\nassociated with neurons that act as validators within the network. This specialized form of trust reflects\nthe validators' reliability and integrity in their role, which is crucial for maintaining the network's\nstability and security.\n\nValidator trust values are particularly important for the network's consensus and validation processes,\ndetermining the validators' influence and responsibilities in these critical functions.\n\nReturns:\n    NDArray: A tensor of validator trust values, specifically applicable to neurons serving as validators, where higher values denote greater trustworthiness in their validation roles.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "D": {
    "name": "D",
    "docstring": "Represents the dividends received by neurons in the Bittensor network. Dividends are a form of reward or\ndistribution, typically given to neurons based on their stake, performance, and contribution to the network.\nThey are an integral part of the network's incentive structure, encouraging active and beneficial participation.\n\nReturns:\n    NDArray: A tensor of dividend values, where each element indicates the dividends received by a neuron, reflecting their share of network rewards.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "B": {
    "name": "B",
    "docstring": "Bonds in the Bittensor network represent a speculative reward mechanism where neurons can accumulate\nbonds in other neurons. Bonds are akin to investments or stakes in other neurons, reflecting a belief in\ntheir future value or performance. This mechanism encourages correct weighting and collaboration\namong neurons while providing an additional layer of incentive.\n\nReturns:\n    NDArray: A tensor representing the bonds held by each neuron, where each value signifies the proportion of bonds owned by one neuron in another.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "W": {
    "name": "W",
    "docstring": "Represents the weights assigned to each neuron in the Bittensor network. In the context of Bittensor,\nweights are crucial for determining the influence and interaction between neurons. Each neuron is responsible\nfor setting its weights, which are then recorded on a digital ledger. These weights are reflective of the\nneuron's assessment or judgment of other neurons in the network.\n\nThe weight matrix :math:`W = [w_{ij}]` is a key component of the network's architecture, where the :math:`i^{th}` row is set by\nneuron :math:`i` and represents its weights towards other neurons. These weights influence the ranking and incentive\nmechanisms within the network. Higher weights from a neuron towards another can imply greater trust or value\nplaced on that neuron's contributions.\n\nReturns:\n    NDArray: A tensor of inter-peer weights, where each element :math:`w_{ij}` represents the weight assigned by neuron :math:`i` to neuron :math:`j`. This matrix is fundamental to the network's functioning, influencing the distribution of incentives and the inter-neuronal dynamics.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "hotkeys": {
    "name": "hotkeys",
    "docstring": "Represents a list of ``hotkeys`` for each neuron in the Bittensor network.\n\nHotkeys are unique identifiers used by neurons for active participation in the network, such as sending and receiving information or\ntransactions. They are akin to public keys in cryptographic systems and are essential for identifying and authenticating neurons within the network's operations.\n\nReturns:\n    List[str]: A list of hotkeys, with each string representing the hotkey of a corresponding neuron.\n\n    These keys are crucial for the network's security and integrity, ensuring proper identification and authorization of network participants.\n\nNote:\n    While the `NeurIPS paper <https://bittensor.com/pdfs/academia/NeurIPS_DAO_Workshop_2022_3_3.pdf>`_ may not explicitly detail the concept of hotkeys, they are a fundamental  of decentralized networks for secure and authenticated interactions.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "List[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "coldkeys": {
    "name": "coldkeys",
    "docstring": "Contains a list of ``coldkeys`` for each neuron in the Bittensor network.\n\nColdkeys are similar to hotkeys but are typically used for more secure, offline activities such as storing assets or offline signing of transactions. They are an important aspect of a neuron's security, providing an additional layer of protection for sensitive operations and assets.\n\nReturns:\n    List[str]: A list of coldkeys, each string representing the coldkey of a neuron. These keys play a vital role in the secure management of assets and sensitive operations within the network.\n\nNote:\n    The concept of coldkeys, while not explicitly covered in the NeurIPS paper, is a standard practice in\n    blockchain and decentralized networks for enhanced security and asset protection.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "List[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "addresses": {
    "name": "addresses",
    "docstring": "Provides a list of IP addresses for each neuron in the Bittensor network. These addresses are used for\nnetwork communication, allowing neurons to connect, interact, and exchange information with each other.\nIP addresses are fundamental for the network's peer-to-peer communication infrastructure.\n\nReturns:\n    List[str]: A list of IP addresses, with each string representing the address of a neuron. These addresses enable the decentralized, distributed nature of the network, facilitating direct communication and data exchange among neurons.\n\nNote:\n    While IP addresses are a basic aspect of network communication, specific details about their use in\n    the Bittensor network may not be covered in the `NeurIPS paper <https://bittensor.com/pdfs/academia/NeurIPS_DAO_Workshop_2022_3_3.pdf>`_. They are, however, integral to the\n    functioning of any distributed network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "List[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "metadata": {
    "name": "metadata",
    "docstring": "Retrieves the metadata of the metagraph, providing key information about the current state of the\nBittensor network. This metadata includes details such as the network's unique identifier (``netuid``),\nthe total number of neurons (``n``), the current block number, the network's name, and the version of\nthe Bittensor network.\n\nReturns:\n    dict: A dictionary containing essential metadata about the metagraph, including:\n\n    - ``netuid``: The unique identifier for the network.\n    - ``n``: The total number of neurons in the network.\n    - ``block``: The current block number in the network's blockchain.\n    - ``network``: The name of the Bittensor network.\n    - ``version``: The version number of the Bittensor software.\n\nNote:\n    This metadata is crucial for understanding the current state and configuration of the network, as well as for tracking its evolution over time.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "state_dict": {
    "name": "state_dict",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "sync": {
    "name": "sync",
    "docstring": "Synchronizes the metagraph with the Bittensor network's current state. It updates the metagraph's attributes\nto reflect the latest data from the network, ensuring the metagraph represents the most current state of the network.\n\nArgs:\n    block (Optional[int]): A specific block number to synchronize with. If None, the metagraph syncs with the latest block.\n                            This allows for historical analysis or specific state examination of the network.\n    lite (bool): If True, a lite version of the metagraph is used for quicker synchronization. This is beneficial\n                when full detail is not necessary, allowing for reduced computational and time overhead.\n    subtensor (Optional[bittensor.subtensor]): An instance of the subtensor class from Bittensor, providing an\n                                                interface to the underlying blockchain data. If provided, this\n                                                instance is used for data retrieval during synchronization.\n\nReturns:\n    metagraph: The metagraph instance, updated to the state of the specified block or the latest network state.\n\nExample:\n    Sync the metagraph with the latest block from the subtensor, using the lite version for efficiency::\n\n        metagraph.sync(subtensor=subtensor)\n\n    Sync with a specific block number for detailed analysis::\n\n        metagraph.sync(block=12345, lite=False, subtensor=subtensor)\n\nNOTE:\n    If attempting to access data beyond the previous 300 blocks, you **must** use the ``archive`` network for subtensor.\n    Light nodes are configured only to store the previous 300 blocks if connecting to finney or test networks.\n\n    For example::\n\n        subtensor = bittensor.subtensor(network='archive')",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      },
      {
        "name": "lite",
        "type": "bool"
      },
      {
        "name": "subtensor",
        "type": "Optional['bittensor.subtensor']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_initialize_subtensor": {
    "name": "_initialize_subtensor",
    "docstring": "Initializes the subtensor to be used for syncing the metagraph.\n\nThis method ensures that a subtensor instance is available and properly set up for data retrieval during the synchronization process.\n\nIf no subtensor is provided, this method is responsible for creating a new instance of the subtensor, configured according to the current network settings.\n\nArgs:\n    subtensor: The subtensor instance provided for initialization. If ``None``, a new subtensor instance is created using the current network configuration.\n\nReturns:\n    subtensor: The initialized subtensor instance, ready to be used for syncing the metagraph.\n\nInternal Usage:\n    Used internally during the sync process to ensure a valid subtensor instance is available::\n\n        subtensor = self._initialize_subtensor(subtensor)",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_assign_neurons": {
    "name": "_assign_neurons",
    "docstring": "Assigns neurons to the metagraph based on the provided block number and the lite flag.\n\nThis method is responsible for fetching and setting the neuron data in the metagraph, which includes neuron attributes like UID, stake, trust, and other relevant information.\n\nArgs:\n    block: The block number for which the neuron data needs to be fetched. If ``None``, the latest block data is used.\n    lite: A boolean flag indicating whether to use a lite version of the neuron data. The lite version typically includes essential information and is quicker to fetch and process.\n    subtensor: The subtensor instance used for fetching neuron data from the network.\n\nInternal Usage:\n    Used internally during the sync process to fetch and set neuron data::\n\n        self._assign_neurons(block, lite, subtensor)",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": null
      },
      {
        "name": "lite",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_create_tensor": {
    "name": "_create_tensor",
    "docstring": "Creates a numpy array with the given data and data type. This method is a utility function used internally to encapsulate data into a np.array, making it compatible with the metagraph's numpy model structure.\n\nArgs:\n    data: The data to be included in the tensor. This could be any numeric data, like stakes, ranks, etc.\n    dtype: The data type for the tensor, typically a numpy data type like ``np.float32`` or ``np.int64``.\n\nReturns:\n    A tensor parameter encapsulating the provided data.\n\nInternal Usage:\n    Used internally to create tensor parameters for various metagraph attributes::\n\n        self.stake = self._create_tensor(neuron_stakes, dtype=np.float32)",
    "parameters": [
      {
        "name": "data",
        "type": null
      },
      {
        "name": "dtype",
        "type": null
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_set_weights_and_bonds": {
    "name": "_set_weights_and_bonds",
    "docstring": "Computes and sets the weights and bonds for each neuron in the metagraph. This method is responsible for processing the raw weight and bond data obtained from the network and converting it into a structured format suitable for the metagraph model.\n\nArgs:\n    subtensor: The subtensor instance used for fetching weights and bonds data. If ``None``, the weights and bonds are not updated.\n\nInternal Usage:\n    Used internally during the sync process to update the weights and bonds of the neurons::\n\n        self._set_weights_and_bonds(subtensor=subtensor)",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "subtensor",
        "type": "Optional[bittensor.subtensor]"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_process_weights_or_bonds": {
    "name": "_process_weights_or_bonds",
    "docstring": "Processes the raw weights or bonds data and converts it into a structured tensor format. This method handles the transformation of neuron connection data (``weights`` or ``bonds``) from a list or other unstructured format into a tensor that can be utilized within the metagraph model.\n\nArgs:\n    data: The raw weights or bonds data to be processed. This data typically comes from the subtensor.\n    attribute: A string indicating whether the data is ``weights`` or ``bonds``, which determines the specific processing steps to be applied.\n\nReturns:\n    A tensor parameter encapsulating the processed weights or bonds data.\n\nInternal Usage:\n    Used internally to process and set weights or bonds for the neurons::\n\n        self.weights = self._process_weights_or_bonds(raw_weights_data, \"weights\")",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "data",
        "type": null
      },
      {
        "name": "attribute",
        "type": "str"
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_set_metagraph_attributes": {
    "name": "_set_metagraph_attributes",
    "docstring": "Sets various attributes of the metagraph based on the latest network data fetched from the subtensor.\n\nThis method updates parameters like the number of neurons, block number, stakes, trusts, ranks, and other neuron-specific information.\n\nArgs:\n    block: The block number for which the metagraph attributes need to be set. If ``None``, the latest block data is used.\n    subtensor: The subtensor instance used for fetching the latest network data.\n\nInternal Usage:\n    Used internally during the sync process to update the metagraph's attributes::\n\n        self._set_metagraph_attributes(block, subtensor)",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "_process_root_weights": {
    "name": "_process_root_weights",
    "docstring": "Specifically processes the root weights data for the metagraph. This method is similar to :func:`_process_weights_or_bonds` but is tailored for processing root weights, which have a different structure and significance in the network.\n\nArgs:\n    data: The raw root weights data to be processed.\n    attribute: A string indicating the attribute type, here it's typically ``weights``.\n    subtensor: The subtensor instance used for additional data and context needed in processing.\n\nReturns:\n    A tensor parameter encapsulating the processed root weights data.\n\nInternal Usage:\n    Used internally to process and set root weights for the metagraph::\n\n        self.root_weights = self._process_root_weights(\n            raw_root_weights_data, \"weights\", subtensor\n            )",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "data",
        "type": null
      },
      {
        "name": "attribute",
        "type": "str"
      },
      {
        "name": "subtensor",
        "type": "bittensor.subtensor"
      }
    ],
    "returns": "Union[NDArray, 'torch.nn.Parameter']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "save": {
    "name": "save",
    "docstring": "Saves the current state of the metagraph to a file on disk. This function is crucial for persisting the current state of the network's metagraph, which can later be reloaded or analyzed. The save operation includes all neuron attributes and parameters, ensuring a complete snapshot of the metagraph's state.\n\nReturns:\n    metagraph: The metagraph instance after saving its state.\n\nExample:\n    Save the current state of the metagraph to the default directory::\n\n        metagraph.save()\n\n    The saved state can later be loaded to restore or analyze the metagraph's state at this point.\n\n    If using the default save path::\n\n        metagraph.load()\n\n    If using a custom save path::\n\n        metagraph.load_from_path(dir_path)",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'metagraph'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "load": {
    "name": "load",
    "docstring": "Loads the state of the metagraph from the default save directory. This method is instrumental for restoring the metagraph to its last saved state. It automatically identifies the save directory based on the ``network`` and ``netuid`` properties of the metagraph, locates the latest block file in that directory, and loads all metagraph parameters from it.\n\nThis functionality is particularly beneficial when continuity in the state of the metagraph is necessary\nacross different runtime sessions, or after a restart of the system. It ensures that the metagraph reflects\nthe exact state it was in at the last save point, maintaining consistency in the network's representation.\n\nThe method delegates to ``load_from_path``, supplying it with the directory path constructed from the metagraph's current ``network`` and ``netuid`` properties. This abstraction simplifies the process of loading the metagraph's state for the user, requiring no direct path specifications.\n\nReturns:\n    metagraph: The metagraph instance after loading its state from the default directory.\n\nExample:\n    Load the metagraph state from the last saved snapshot in the default directory::\n\n        metagraph.load()\n\n    After this operation, the metagraph's parameters and neuron data are restored to their state at the time of the last save in the default directory.\n\nNote:\n    The default save directory is determined based on the metagraph's ``network`` and ``netuid`` attributes. It is important to ensure that these attributes are set correctly and that the default save directory contains the appropriate state files for the metagraph.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "load_from_path": {
    "name": "load_from_path",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "dir_path",
        "type": "str"
      }
    ],
    "returns": "'metagraph'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/metagraph.py"
  },
  "display_mnemonic_msg": {
    "name": "display_mnemonic_msg",
    "docstring": "Display the mnemonic and a warning message to keep the mnemonic safe.\n\nArgs:\n    keypair (Keypair): Keypair object.\n    key_type (str): Type of the key (coldkey or hotkey).",
    "parameters": [
      {
        "name": "keypair",
        "type": "Keypair"
      },
      {
        "name": "key_type",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "config": {
    "name": "config",
    "docstring": "Get config from the argument parser.\n\nReturn:\n    config (bittensor.config): config object",
    "parameters": [
      {
        "name": "cls",
        "type": null
      }
    ],
    "returns": "bittensor.config",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "help": {
    "name": "help",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "add_args": {
    "name": "add_args",
    "docstring": null,
    "parameters": [
      {
        "name": "parser",
        "type": "argparse.ArgumentParser"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/list.py"
  },
  "create_if_non_existent": {
    "name": "create_if_non_existent",
    "docstring": "Checks for existing coldkeypub and hotkeys, and creates them if non-existent.\n\nArgs:\n    coldkey_use_password (bool, optional): Whether to use a password for coldkey. Defaults to ``True``.\n    hotkey_use_password (bool, optional): Whether to use a password for hotkey. Defaults to ``False``.\n\nReturns:\n    wallet: The wallet object.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_use_password",
        "type": "bool"
      },
      {
        "name": "hotkey_use_password",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "create": {
    "name": "create",
    "docstring": "Checks for existing coldkeypub and hotkeys, and creates them if non-existent.\n\nArgs:\n    coldkey_use_password (bool, optional): Whether to use a password for coldkey. Defaults to ``True``.\n    hotkey_use_password (bool, optional): Whether to use a password for hotkey. Defaults to ``False``.\n\nReturns:\n    wallet: The wallet object.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_use_password",
        "type": "bool"
      },
      {
        "name": "hotkey_use_password",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "recreate": {
    "name": "recreate",
    "docstring": "Checks for existing coldkeypub and hotkeys and creates them if non-existent.\n\nArgs:\n    coldkey_use_password (bool, optional): Whether to use a password for coldkey. Defaults to ``True``.\n    hotkey_use_password (bool, optional): Whether to use a password for hotkey. Defaults to ``False``.\n\nReturns:\n    wallet: The wallet object.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_use_password",
        "type": "bool"
      },
      {
        "name": "hotkey_use_password",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "hotkey_file": {
    "name": "hotkey_file",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "coldkey_file": {
    "name": "coldkey_file",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "coldkeypub_file": {
    "name": "coldkeypub_file",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "set_hotkey": {
    "name": "set_hotkey",
    "docstring": "Sets the hotkey for the wallet.\n\nArgs:\n    keypair (bittensor.Keypair): The hotkey keypair.\n    encrypt (bool, optional): Whether to encrypt the hotkey. Defaults to ``False``.\n    overwrite (bool, optional): Whether to overwrite an existing hotkey. Defaults to ``False``.\n\nReturns:\n    bittensor.keyfile: The hotkey file.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "keypair",
        "type": "'bittensor.Keypair'"
      },
      {
        "name": "encrypt",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "set_coldkeypub": {
    "name": "set_coldkeypub",
    "docstring": "Sets the coldkeypub for the wallet.\n\nArgs:\n    keypair (bittensor.Keypair): The coldkeypub keypair.\n    encrypt (bool, optional): Whether to encrypt the coldkeypub. Defaults to ``False``.\n    overwrite (bool, optional): Whether to overwrite an existing coldkeypub. Defaults to ``False``.\n\nReturns:\n    bittensor.keyfile: The coldkeypub file.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "keypair",
        "type": "'bittensor.Keypair'"
      },
      {
        "name": "encrypt",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "set_coldkey": {
    "name": "set_coldkey",
    "docstring": "Sets the coldkey for the wallet.\n\nArgs:\n    keypair (bittensor.Keypair): The coldkey keypair.\n    encrypt (bool, optional): Whether to encrypt the coldkey. Defaults to ``True``.\n    overwrite (bool, optional): Whether to overwrite an existing coldkey. Defaults to ``False``.\n\nReturns:\n    bittensor.keyfile: The coldkey file.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "keypair",
        "type": "'bittensor.Keypair'"
      },
      {
        "name": "encrypt",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      }
    ],
    "returns": "'bittensor.keyfile'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "get_coldkey": {
    "name": "get_coldkey",
    "docstring": "Gets the coldkey from the wallet.\n\nArgs:\n    password (str, optional): The password to decrypt the coldkey. Defaults to ``None``.\n\nReturns:\n    bittensor.Keypair: The coldkey keypair.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "get_hotkey": {
    "name": "get_hotkey",
    "docstring": "Gets the hotkey from the wallet.\n\nArgs:\n    password (str, optional): The password to decrypt the hotkey. Defaults to ``None``.\n\nReturns:\n    bittensor.Keypair: The hotkey keypair.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "get_coldkeypub": {
    "name": "get_coldkeypub",
    "docstring": "Gets the coldkeypub from the wallet.\n\nArgs:\n    password (str, optional): The password to decrypt the coldkeypub. Defaults to ``None``.\n\nReturns:\n    bittensor.Keypair: The coldkeypub keypair.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "hotkey": {
    "name": "hotkey",
    "docstring": "Loads the hotkey from wallet.path/wallet.name/hotkeys/wallet.hotkey or raises an error.\n\nReturns:\n    hotkey (Keypair):\n        hotkey loaded from config arguments.\nRaises:\n    KeyFileError: Raised if the file is corrupt of non-existent.\n    CryptoKeyError: Raised if the user enters an incorrec password for an encrypted keyfile.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "coldkey": {
    "name": "coldkey",
    "docstring": "Loads the hotkey from wallet.path/wallet.name/coldkey or raises an error.\n\nReturns:\n    coldkey (Keypair): coldkey loaded from config arguments.\nRaises:\n    KeyFileError: Raised if the file is corrupt of non-existent.\n    CryptoKeyError: Raised if the user enters an incorrec password for an encrypted keyfile.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "coldkeypub": {
    "name": "coldkeypub",
    "docstring": "Loads the coldkeypub from wallet.path/wallet.name/coldkeypub.txt or raises an error.\n\nReturns:\n    coldkeypub (Keypair): coldkeypub loaded from config arguments.\nRaises:\n    KeyFileError: Raised if the file is corrupt of non-existent.\n    CryptoKeyError: Raised if the user enters an incorrect password for an encrypted keyfile.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "create_coldkey_from_uri": {
    "name": "create_coldkey_from_uri",
    "docstring": "Creates coldkey from suri string, optionally encrypts it with the user-provided password.\n\nArgs:\n    uri: (str, required):\n        URI string to use i.e., ``/Alice`` or ``/Bob``.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the coldkey under the same path ``<wallet path>/<wallet name>/coldkey``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created coldkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uri",
        "type": "str"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "create_hotkey_from_uri": {
    "name": "create_hotkey_from_uri",
    "docstring": "Creates hotkey from suri string, optionally encrypts it with the user-provided password.\n\nArgs:\n    uri: (str, required):\n        URI string to use i.e., ``/Alice`` or ``/Bob``\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the hotkey under the same path ``<wallet path>/<wallet name>/hotkeys/<hotkey>``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created hotkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uri",
        "type": "str"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "new_coldkey": {
    "name": "new_coldkey",
    "docstring": "Creates a new coldkey, optionally encrypts it with the user-provided password and saves to disk.\n\nArgs:\n    n_words: (int, optional):\n        Number of mnemonic words to use.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the coldkey under the same path ``<wallet path>/<wallet name>/coldkey``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created coldkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "n_words",
        "type": "int"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "create_new_coldkey": {
    "name": "create_new_coldkey",
    "docstring": "Creates a new coldkey, optionally encrypts it with the user-provided password and saves to disk.\n\nArgs:\n    n_words: (int, optional):\n        Number of mnemonic words to use.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the coldkey under the same path ``<wallet path>/<wallet name>/coldkey``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created coldkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "n_words",
        "type": "int"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "new_hotkey": {
    "name": "new_hotkey",
    "docstring": "Creates a new hotkey, optionally encrypts it with the user-provided password and saves to disk.\n\nArgs:\n    n_words: (int, optional):\n        Number of mnemonic words to use.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the hotkey under the same path ``<wallet path>/<wallet name>/hotkeys/<hotkey>``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created hotkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "n_words",
        "type": "int"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "create_new_hotkey": {
    "name": "create_new_hotkey",
    "docstring": "Creates a new hotkey, optionally encrypts it with the user-provided password and saves to disk.\n\nArgs:\n    n_words: (int, optional):\n        Number of mnemonic words to use.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Will this operation overwrite the hotkey under the same path <wallet path>/<wallet name>/hotkeys/<hotkey>\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created hotkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "n_words",
        "type": "int"
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "regenerate_coldkeypub": {
    "name": "regenerate_coldkeypub",
    "docstring": "Regenerates the coldkeypub from the passed ``ss58_address`` or public_key and saves the file. Requires either ``ss58_address`` or public_key to be passed.\n\nArgs:\n    ss58_address: (str, optional):\n        Address as ``ss58`` string.\n    public_key: (str | bytes, optional):\n        Public key as hex string or bytes.\n    overwrite (bool, optional) (default: False):\n        Determins if this operation overwrites the coldkeypub (if exists) under the same path ``<wallet path>/<wallet name>/coldkeypub``.\nReturns:\n    wallet (bittensor.wallet):\n        Newly re-generated wallet with coldkeypub.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "ss58_address",
        "type": "Optional[str]"
      },
      {
        "name": "public_key",
        "type": "Optional[Union[str, bytes]]"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "regenerate_coldkey": {
    "name": "regenerate_coldkey",
    "docstring": "Regenerates the coldkey from the passed mnemonic or seed, or JSON encrypts it with the user's password and saves the file.\n\nArgs:\n    mnemonic: (Union[list, str], optional):\n        Key mnemonic as list of words or string space separated words.\n    seed: (str, optional):\n        Seed as hex string.\n    json: (Tuple[Union[str, Dict], str], optional):\n        Restore from encrypted JSON backup as ``(json_data: Union[str, Dict], passphrase: str)``\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determines if this operation overwrites the coldkey under the same path ``<wallet path>/<wallet name>/coldkey``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created coldkey.\n\nNote:\n    Uses priority order: ``mnemonic > seed > json``.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "regenerate_hotkey": {
    "name": "regenerate_hotkey",
    "docstring": "Regenerates the hotkey from passed mnemonic or seed, encrypts it with the user's password and saves the file.\n\nArgs:\n    mnemonic: (Union[list, str], optional):\n        Key mnemonic as list of words or string space separated words.\n    seed: (str, optional):\n        Seed as hex string.\n    json: (Tuple[Union[str, Dict], str], optional):\n        Restore from encrypted JSON backup as ``(json_data: Union[str, Dict], passphrase: str)``.\n    use_password (bool, optional):\n        Is the created key password protected.\n    overwrite (bool, optional):\n        Determies if this operation overwrites the hotkey under the same path ``<wallet path>/<wallet name>/hotkeys/<hotkey>``.\nReturns:\n    wallet (bittensor.wallet):\n        This object with newly created hotkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "use_password",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "suppress",
        "type": "bool"
      }
    ],
    "returns": "'wallet'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/wallet.py"
  },
  "serialized_keypair_to_keyfile_data": {
    "name": "serialized_keypair_to_keyfile_data",
    "docstring": "Serializes keypair object into keyfile data.\n\nArgs:\n    keypair (bittensor.Keypair): The keypair object to be serialized.\nReturns:\n    data (bytes): Serialized keypair data.",
    "parameters": [
      {
        "name": "keypair",
        "type": "'bittensor.Keypair'"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "deserialize_keypair_from_keyfile_data": {
    "name": "deserialize_keypair_from_keyfile_data",
    "docstring": "Deserializes Keypair object from passed keyfile data.\n\nArgs:\n    keyfile_data (bytes): The keyfile data as bytes to be loaded.\nReturns:\n    keypair (bittensor.Keypair): The Keypair loaded from bytes.\nRaises:\n    KeyFileError: Raised if the passed bytes cannot construct a keypair object.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "'bittensor.Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "validate_password": {
    "name": "validate_password",
    "docstring": "Validates the password against a password policy.\n\nArgs:\n    password (str): The password to verify.\nReturns:\n    valid (bool): ``True`` if the password meets validity requirements.",
    "parameters": [
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "ask_password_to_encrypt": {
    "name": "ask_password_to_encrypt",
    "docstring": "Prompts the user to enter a password for key encryption.\n\nReturns:\n    password (str): The valid password entered by the user.",
    "parameters": [],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keyfile_data_is_encrypted_nacl": {
    "name": "keyfile_data_is_encrypted_nacl",
    "docstring": "Returns true if the keyfile data is NaCl encrypted.\n\nArgs:\n    keyfile_data ( bytes, required ):\n        Bytes to validate.\nReturns:\n    is_nacl (bool):\n        ``True`` if data is ansible encrypted.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keyfile_data_is_encrypted_ansible": {
    "name": "keyfile_data_is_encrypted_ansible",
    "docstring": "Returns true if the keyfile data is ansible encrypted.\n\nArgs:\n    keyfile_data (bytes): The bytes to validate.\nReturns:\n    is_ansible (bool): True if the data is ansible encrypted.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keyfile_data_is_encrypted_legacy": {
    "name": "keyfile_data_is_encrypted_legacy",
    "docstring": "Returns true if the keyfile data is legacy encrypted.\nArgs:\n    keyfile_data (bytes): The bytes to validate.\nReturns:\n    is_legacy (bool): ``True`` if the data is legacy encrypted.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keyfile_data_is_encrypted": {
    "name": "keyfile_data_is_encrypted",
    "docstring": "Returns ``true`` if the keyfile data is encrypted.\n\nArgs:\n    keyfile_data (bytes): The bytes to validate.\nReturns:\n    is_encrypted (bool): ``True`` if the data is encrypted.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keyfile_data_encryption_method": {
    "name": "keyfile_data_encryption_method",
    "docstring": "Returns ``true`` if the keyfile data is encrypted.\n\nArgs:\n    keyfile_data ( bytes, required ):\n        Bytes to validate\nReturns:\n    encryption_method (bool):\n        ``True`` if data is encrypted.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "legacy_encrypt_keyfile_data": {
    "name": "legacy_encrypt_keyfile_data",
    "docstring": null,
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "encrypt_keyfile_data": {
    "name": "encrypt_keyfile_data",
    "docstring": "Encrypts the passed keyfile data using ansible vault.\n\nArgs:\n    keyfile_data (bytes): The bytes to encrypt.\n    password (str, optional): The password used to encrypt the data. If ``None``, asks for user input.\nReturns:\n    encrypted_data (bytes): The encrypted data.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "get_coldkey_password_from_environment": {
    "name": "get_coldkey_password_from_environment",
    "docstring": "Retrieves the cold key password from the environment variables.\n\nArgs:\n    coldkey_name (str): The name of the cold key.\nReturns:\n    password (str): The password retrieved from the environment variables, or ``None`` if not found.",
    "parameters": [
      {
        "name": "coldkey_name",
        "type": "str"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "decrypt_keyfile_data": {
    "name": "decrypt_keyfile_data",
    "docstring": "Decrypts the passed keyfile data using ansible vault.\n\nArgs:\n    keyfile_data (bytes): The bytes to decrypt.\n    password (str, optional): The password used to decrypt the data. If ``None``, asks for user input.\n    coldkey_name (str, optional): The name of the cold key. If provided, retrieves the password from environment variables.\nReturns:\n    decrypted_data (bytes): The decrypted data.\nRaises:\n    KeyFileError: Raised if the file is corrupted or if the password is incorrect.",
    "parameters": [
      {
        "name": "keyfile_data",
        "type": "bytes"
      },
      {
        "name": "password",
        "type": "str"
      },
      {
        "name": "coldkey_name",
        "type": "Optional[str]"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "keypair": {
    "name": "keypair",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "data": {
    "name": "data",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "keyfile_data": {
    "name": "keyfile_data",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "set_keypair": {
    "name": "set_keypair",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "keypair",
        "type": "'Keypair'"
      },
      {
        "name": "encrypt",
        "type": "bool"
      },
      {
        "name": "overwrite",
        "type": "bool"
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "get_keypair": {
    "name": "get_keypair",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": "'Keypair'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "make_dirs": {
    "name": "make_dirs",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "exists_on_device": {
    "name": "exists_on_device",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "is_readable": {
    "name": "is_readable",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "is_writable": {
    "name": "is_writable",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "is_encrypted": {
    "name": "is_encrypted",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "_may_overwrite": {
    "name": "_may_overwrite",
    "docstring": "Asks the user if it is okay to overwrite the file.\n\nReturns:\n    may_overwrite (bool): ``True`` if the user allows overwriting the file.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "check_and_update_encryption": {
    "name": "check_and_update_encryption",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "no_prompt",
        "type": null
      },
      {
        "name": "print_result",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "encrypt": {
    "name": "encrypt",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "decrypt": {
    "name": "decrypt",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "password",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/keyfile_mock.py"
  },
  "_read_keyfile_data_from_file": {
    "name": "_read_keyfile_data_from_file",
    "docstring": "Reads the keyfile data from the file.\n\nReturns:\n    keyfile_data (bytes): The keyfile data stored under the path.\nRaises:\n    KeyFileError: Raised if the file does not exist or is not readable.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "_write_keyfile_data_to_file": {
    "name": "_write_keyfile_data_to_file",
    "docstring": "Writes the keyfile data to the file.\n\nArgs:\n    keyfile_data (bytes): The byte data to store under the path.\n    overwrite (bool, optional): If ``True``, overwrites the data without asking for permission from the user. Default is ``False``.\nRaises:\n    KeyFileError: Raised if the file is not writable or the user responds No to the overwrite prompt.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "keyfile_data",
        "type": "bytes"
      },
      {
        "name": "overwrite",
        "type": "bool"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/keyfile.py"
  },
  "close_session": {
    "name": "close_session",
    "docstring": "Closes the internal `aiohttp <https://github.com/aio-libs/aiohttp>`_ client session synchronously.\n\nThis method ensures the proper closure and cleanup of the aiohttp client session, releasing any\nresources like open connections and internal buffers. It is crucial for preventing resource leakage\nand should be called when the dendrite instance is no longer in use, especially in synchronous contexts.\n\nNote:\n    This method utilizes asyncio's event loop to close the session asynchronously from a synchronous context. It is advisable to use this method only when asynchronous context management is not feasible.\n\nUsage:\n    When finished with dendrite in a synchronous context\n    :func:`dendrite_instance.close_session()`.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "_get_endpoint_url": {
    "name": "_get_endpoint_url",
    "docstring": "Constructs the endpoint URL for a network request to a target axon.\n\nThis internal method generates the full HTTP URL for sending a request to the specified axon. The\nURL includes the IP address and port of the target axon, along with the specific request name. It\ndifferentiates between requests to the local system (using '0.0.0.0') and external systems.\n\nArgs:\n    target_axon: The target axon object containing IP and port information.\n    request_name: The specific name of the request being made.\n\nReturns:\n    str: A string representing the complete HTTP URL for the request.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "target_axon",
        "type": null
      },
      {
        "name": "request_name",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "_handle_request_errors": {
    "name": "_handle_request_errors",
    "docstring": "Handles exceptions that occur during network requests, updating the synapse with appropriate status codes and messages.\n\nThis method interprets different types of exceptions and sets the corresponding status code and\nmessage in the synapse object. It covers common network errors such as connection issues and timeouts.\n\nArgs:\n    synapse: The synapse object associated with the request.\n    request_name: The name of the request during which the exception occurred.\n    exception: The exception object caught during the request.\n\nNote:\n    This method updates the synapse object in-place.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "synapse",
        "type": null
      },
      {
        "name": "request_name",
        "type": null
      },
      {
        "name": "exception",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "_log_outgoing_request": {
    "name": "_log_outgoing_request",
    "docstring": "Logs information about outgoing requests for debugging purposes.\n\nThis internal method logs key details about each outgoing request, including the size of the\nrequest, the name of the synapse, the axon's details, and a success indicator. This information\nis crucial for monitoring and debugging network activity within the Bittensor network.\n\nTo turn on debug messages, set the environment variable BITTENSOR_DEBUG to ``1``, or call the bittensor debug method like so::\n\n    import bittensor\n    bittensor.debug()\n\nArgs:\n    synapse: The synapse object representing the request being sent.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "synapse",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "_log_incoming_response": {
    "name": "_log_incoming_response",
    "docstring": "Logs information about incoming responses for debugging and monitoring.\n\nSimilar to :func:`_log_outgoing_request`, this method logs essential details of the incoming responses,\nincluding the size of the response, synapse name, axon details, status code, and status message.\nThis logging is vital for troubleshooting and understanding the network interactions in Bittensor.\n\nArgs:\n    synapse: The synapse object representing the received response.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "synapse",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "query": {
    "name": "query",
    "docstring": "Makes a synchronous request to multiple target Axons and returns the server responses.\n\nCleanup is automatically handled and sessions are closed upon completed requests.\n\nArgs:\n    axons (Union[List[Union['bittensor.AxonInfo', 'bittensor.axon']], Union['bittensor.AxonInfo', 'bittensor.axon']]):\n        The list of target Axon information.\n    synapse (bittensor.Synapse, optional): The Synapse object. Defaults to :func:`bittensor.Synapse()`.\n    timeout (float, optional): The request timeout duration in seconds.\n        Defaults to ``12.0`` seconds.\nReturns:\n    Union[bittensor.Synapse, List[bittensor.Synapse]]: If a single target axon is provided, returns the response from that axon. If multiple target axons are provided, returns a list of responses from all target axons.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "List[Union[AsyncGenerator[Any, Any], bittensor.Synapse, bittensor.StreamingSynapse]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "preprocess_synapse_for_request": {
    "name": "preprocess_synapse_for_request",
    "docstring": "Preprocesses the synapse for making a request. This includes building\nheaders for Dendrite and Axon and signing the request.\n\nArgs:\n    target_axon_info (bittensor.AxonInfo): The target axon information.\n    synapse (bittensor.Synapse): The synapse object to be preprocessed.\n    timeout (float, optional): The request timeout duration in seconds.\n        Defaults to ``12.0`` seconds.\n\nReturns:\n    bittensor.Synapse: The preprocessed synapse.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "target_axon_info",
        "type": "bittensor.AxonInfo"
      },
      {
        "name": "synapse",
        "type": "bittensor.Synapse"
      },
      {
        "name": "timeout",
        "type": "float"
      }
    ],
    "returns": "bittensor.Synapse",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "process_server_response": {
    "name": "process_server_response",
    "docstring": "Processes the server response, updates the local synapse state with the\nserver's state and merges headers set by the server.\n\nArgs:\n    server_response (object): The `aiohttp <https://github.com/aio-libs/aiohttp>`_ response object from the server.\n    json_response (dict): The parsed JSON response from the server.\n    local_synapse (bittensor.Synapse): The local synapse object to be updated.\n\nRaises:\n    None: But errors in attribute setting are silently ignored.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "server_response",
        "type": "aiohttp.ClientResponse"
      },
      {
        "name": "json_response",
        "type": "dict"
      },
      {
        "name": "local_synapse",
        "type": "bittensor.Synapse"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/dendrite.py"
  },
  "__del__": {
    "name": "__del__",
    "docstring": "This magic method is called when the Axon object is about to be destroyed.\nIt ensures that the Axon server shuts down properly.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "__split_params__": {
    "name": "__split_params__",
    "docstring": null,
    "parameters": [
      {
        "name": "params",
        "type": "argparse.Namespace"
      },
      {
        "name": "_config",
        "type": "'config'"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "__parse_args__": {
    "name": "__parse_args__",
    "docstring": "Parses the passed args use the passed parser.\n\nArgs:\n    args (List[str]):\n        List of arguments to parse.\n    parser (argparse.ArgumentParser):\n        Command line parser object.\n    strict (bool):\n        If ``true``, the command line arguments are strictly parsed.\nReturns:\n    Namespace:\n        Namespace object created from parser arguments.",
    "parameters": [
      {
        "name": "args",
        "type": "List[str]"
      },
      {
        "name": "parser",
        "type": "argparse.ArgumentParser"
      },
      {
        "name": "strict",
        "type": "bool"
      }
    ],
    "returns": "argparse.Namespace",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "__deepcopy__": {
    "name": "__deepcopy__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "memo",
        "type": null
      }
    ],
    "returns": "'config'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "_remove_private_keys": {
    "name": "_remove_private_keys",
    "docstring": null,
    "parameters": [
      {
        "name": "d",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "copy": {
    "name": "copy",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'config'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "update_with_kwargs": {
    "name": "update_with_kwargs",
    "docstring": "Add config to self",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "kwargs",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "_merge": {
    "name": "_merge",
    "docstring": "Merge two configurations recursively.\nIf there is a conflict, the value from the second configuration will take precedence.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "a",
        "type": null
      },
      {
        "name": "b",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "merge": {
    "name": "merge",
    "docstring": "Merges the current config with another config.\n\nArgs:\n    b: Another config to merge.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "b",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "merge_all": {
    "name": "merge_all",
    "docstring": "Merge all configs in the list into one config.\nIf there is a conflict, the value from the last configuration in the list will take precedence.\n\nArgs:\n    configs (list of config):\n        List of configs to be merged.\n\nReturns:\n    config:\n        Merged config object.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "configs",
        "type": "List['config']"
      }
    ],
    "returns": "'config'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "is_set": {
    "name": "is_set",
    "docstring": "Returns a boolean indicating whether the parameter has been set or is still the default.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "param_name",
        "type": "str"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "__check_for_missing_required_args": {
    "name": "__check_for_missing_required_args",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "parser",
        "type": "argparse.ArgumentParser"
      },
      {
        "name": "args",
        "type": "List[str]"
      }
    ],
    "returns": "List[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "__get_required_args_from_parser": {
    "name": "__get_required_args_from_parser",
    "docstring": null,
    "parameters": [
      {
        "name": "parser",
        "type": "argparse.ArgumentParser"
      }
    ],
    "returns": "List[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/config.py"
  },
  "default": {
    "name": "default",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_worker": {
    "name": "_worker",
    "docstring": null,
    "parameters": [
      {
        "name": "executor_reference",
        "type": null
      },
      {
        "name": "work_queue",
        "type": null
      },
      {
        "name": "initializer",
        "type": null
      },
      {
        "name": "initargs",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "run": {
    "name": "run",
    "docstring": "Lists wallets.",
    "parameters": [
      {
        "name": "cli",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/list.py"
  },
  "is_empty": {
    "name": "is_empty",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "submit": {
    "name": "submit",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "fn",
        "type": "Callable"
      }
    ],
    "returns": "_base.Future",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "_adjust_thread_count": {
    "name": "_adjust_thread_count",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "_initializer_failed": {
    "name": "_initializer_failed",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "shutdown": {
    "name": "shutdown",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wait",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "weakref_cb": {
    "name": "weakref_cb",
    "docstring": null,
    "parameters": [
      {
        "name": "_",
        "type": null
      },
      {
        "name": "q",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/threadpool.py"
  },
  "create_error_response": {
    "name": "create_error_response",
    "docstring": null,
    "parameters": [
      {
        "name": "synapse",
        "type": "bittensor.Synapse"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "log_and_handle_error": {
    "name": "log_and_handle_error",
    "docstring": null,
    "parameters": [
      {
        "name": "synapse",
        "type": "bittensor.Synapse"
      },
      {
        "name": "exception",
        "type": "Exception"
      },
      {
        "name": "status_code",
        "type": "typing.Optional[int]"
      },
      {
        "name": "start_time",
        "type": "typing.Optional[float]"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "install_signal_handlers": {
    "name": "install_signal_handlers",
    "docstring": "Overrides the default signal handlers provided by ``uvicorn.Server``. This method is essential to ensure that the signal handling in the threaded server does not interfere with the main application's flow, especially in a complex asynchronous environment like the Axon server.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "run_in_thread": {
    "name": "run_in_thread",
    "docstring": "Manages the execution of the server in a separate thread, allowing the FastAPI application to run asynchronously without blocking the main thread of the Axon server. This method is a key component in enabling concurrent request handling in the Axon server.\n\nYields:\n    None: This method yields control back to the caller while the server is running in the background thread.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "_wrapper_run": {
    "name": "_wrapper_run",
    "docstring": "A wrapper method for the :func:`run_in_thread` context manager. This method is used internally by the ``start`` method to initiate the server's execution in a separate thread.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "start": {
    "name": "start",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "stop": {
    "name": "stop",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "info": {
    "name": "info",
    "docstring": "Wraps info message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "attach": {
    "name": "attach",
    "docstring": "Attaches custom functions to the Axon server for handling incoming requests. This method enables\nthe Axon to define specific behaviors for request forwarding, verification, blacklisting, and\nprioritization, thereby customizing its interaction within the Bittensor network.\n\nRegisters an API endpoint to the FastAPI application router.\nIt uses the name of the first argument of the :func:`forward_fn` function as the endpoint name.\n\nThe attach method in the Bittensor framework's axon class is a crucial function for registering\nAPI endpoints to the Axon's FastAPI application router. This method allows the Axon server to\ndefine how it handles incoming requests by attaching functions for forwarding, verifying,\nblacklisting, and prioritizing requests. It's a key part of customizing the server's behavior\nand ensuring efficient and secure handling of requests within the Bittensor network.\n\nArgs:\n    forward_fn (Callable): Function to be called when the API endpoint is accessed. It should have at least one argument.\n    blacklist_fn (Callable, optional): Function to filter out undesired requests. It should take the same arguments as :func:`forward_fn` and return a boolean value. Defaults to ``None``, meaning no blacklist filter will be used.\n    priority_fn (Callable, optional): Function to rank requests based on their priority. It should take the same arguments as :func:`forward_fn` and return a numerical value representing the request's priority. Defaults to ``None``, meaning no priority sorting will be applied.\n    verify_fn (Callable, optional): Function to verify requests. It should take the same arguments as :func:`forward_fn` and return a boolean value. If ``None``, :func:`self.default_verify` function will be used.\n\nNote:\n    The methods :func:`forward_fn`, :func:`blacklist_fn`, :func:`priority_fn`, and :func:`verify_fn` should be designed to receive the same parameters.\n\nRaises:\n    AssertionError: If :func:`forward_fn` does not have the signature: ``forward( synapse: YourSynapse ) -> synapse``.\n    AssertionError: If :func:`blacklist_fn` does not have the signature: ``blacklist( synapse: YourSynapse ) -> bool``.\n    AssertionError: If :func:`priority_fn` does not have the signature: ``priority( synapse: YourSynapse ) -> float``.\n    AssertionError: If :func:`verify_fn` does not have the signature: ``verify( synapse: YourSynapse ) -> None``.\n\nReturns:\n    self: Returns the instance of the AxonServer class for potential method chaining.\n\nExample Usage::\n\n    def forward_custom(synapse: MyCustomSynapse) -> MyCustomSynapse:\n        # Custom logic for processing the request\n        return synapse\n\n    def blacklist_custom(synapse: MyCustomSynapse) -> Tuple[bool, str]:\n        return True, \"Allowed!\"\n\n    def priority_custom(synapse: MyCustomSynapse) -> float:\n        return 1.0\n\n    def verify_custom(synapse: MyCustomSynapse):\n        # Custom logic for verifying the request\n        pass\n\n    my_axon = bittensor.axon(...)\n    my_axon.attach(forward_fn=forward_custom, verify_fn=verify_custom)\n\nNote:\n    The :func:`attach` method is fundamental in setting up the Axon server's request handling capabilities,\n    enabling it to participate effectively and securely in the Bittensor network. The flexibility\n    offered by this method allows developers to tailor the Axon's behavior to specific requirements and\n    use cases.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "forward_fn",
        "type": "Callable"
      },
      {
        "name": "blacklist_fn",
        "type": "Optional[Callable]"
      },
      {
        "name": "priority_fn",
        "type": "Optional[Callable]"
      },
      {
        "name": "verify_fn",
        "type": "Optional[Callable]"
      }
    ],
    "returns": "'bittensor.axon'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "check_config": {
    "name": "check_config",
    "docstring": null,
    "parameters": [
      {
        "name": "config",
        "type": "'bittensor.config'"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/list.py"
  },
  "serve": {
    "name": "serve",
    "docstring": "Registers a neuron's serving endpoint on the Bittensor network. This function announces the\nIP address and port where the neuron is available to serve requests, facilitating peer-to-peer\ncommunication within the network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron being served.\n    ip (str): The IP address of the serving neuron.\n    port (int): The port number on which the neuron is serving.\n    protocol (int): The protocol type used by the neuron (e.g., GRPC, HTTP).\n    netuid (int): The unique identifier of the subnetwork.\n    placeholder1 (int, optional): Placeholder parameter for future extensions. Default is ``0``.\n    placeholder2 (int, optional): Placeholder parameter for future extensions. Default is ``0``.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Default is\n        ``False``.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain. Default\n        is ``True``.\n\nReturns:\n    bool: ``True`` if the serve registration is successful, False otherwise.\n\nThis function is essential for establishing the neuron's presence in the network, enabling\nit to participate in the decentralized machine learning processes of Bittensor.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "ip",
        "type": "str"
      },
      {
        "name": "port",
        "type": "int"
      },
      {
        "name": "protocol",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "placeholder1",
        "type": "int"
      },
      {
        "name": "placeholder2",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "ping": {
    "name": "ping",
    "docstring": null,
    "parameters": [
      {
        "name": "r",
        "type": "bittensor.Synapse"
      }
    ],
    "returns": "bittensor.Synapse",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/axon.py"
  },
  "get_size": {
    "name": "get_size",
    "docstring": "Recursively finds size of objects.\n\nThis function traverses every item of a given object and sums their sizes to compute the total size.\n\nArgs:\n    obj (any type): The object to get the size of.\n    seen (set): Set of object ids that have been calculated.\n\nReturns:\n    int: The total size of the object.",
    "parameters": [
      {
        "name": "obj",
        "type": null
      },
      {
        "name": "seen",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "cast_int": {
    "name": "cast_int",
    "docstring": "Converts a string to an integer, if the string is not ``None``.\n\nThis function attempts to convert a string to an integer. If the string is ``None``, it simply returns ``None``.\n\nArgs:\n    raw (str): The string to convert.\n\nReturns:\n    int or None: The converted integer, or ``None`` if the input was ``None``.",
    "parameters": [
      {
        "name": "raw",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "cast_float": {
    "name": "cast_float",
    "docstring": "Converts a string to a float, if the string is not ``None``.\n\nThis function attempts to convert a string to a float. If the string is ``None``, it simply returns ``None``.\n\nArgs:\n    raw (str): The string to convert.\n\nReturns:\n    float or None: The converted float, or ``None`` if the input was ``None``.",
    "parameters": [
      {
        "name": "raw",
        "type": "str"
      }
    ],
    "returns": "float",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "deserialize": {
    "name": "deserialize",
    "docstring": "Deserializes the Tensor object.\n\nReturns:\n    np.array or torch.Tensor: The deserialized tensor object.\n\nRaises:\n    Exception: If the deserialization process encounters an error.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union['np.ndarray', 'torch.Tensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "set_name_type": {
    "name": "set_name_type",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "values",
        "type": null
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "__setattr__": {
    "name": "__setattr__",
    "docstring": "Override the :func:`__setattr__` method to make the ``required_hash_fields`` property read-only.\n\nThis is a security mechanism such that the ``required_hash_fields`` property cannot be\noverridden by the user or malicious code.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "value",
        "type": "Any"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "get_total_size": {
    "name": "get_total_size",
    "docstring": "Get the total size of the current object.\n\nThis method first calculates the size of the current object, then assigns it\nto the instance variable :func:`self.total_size` and finally returns this value.\n\nReturns:\n    int: The total size of the current object.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "is_success": {
    "name": "is_success",
    "docstring": "Checks if the dendrite's status code indicates success.\n\nThis method returns ``True`` if the status code of the dendrite is ``200``,\nwhich typically represents a successful HTTP request.\n\nReturns:\n    bool: ``True`` if dendrite's status code is ``200``, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "is_failure": {
    "name": "is_failure",
    "docstring": "Checks if the dendrite's status code indicates failure.\n\nThis method returns ``True`` if the status code of the dendrite is not ``200``,\nwhich would mean the HTTP request was not successful.\n\nReturns:\n    bool: ``True`` if dendrite's status code is not ``200``, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "is_timeout": {
    "name": "is_timeout",
    "docstring": "Checks if the dendrite's status code indicates a timeout.\n\nThis method returns ``True`` if the status code of the dendrite is ``408``,\nwhich is the HTTP status code for a request timeout.\n\nReturns:\n    bool: ``True`` if dendrite's status code is ``408``, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "is_blacklist": {
    "name": "is_blacklist",
    "docstring": "Checks if the dendrite's status code indicates a blacklisted request.\n\nThis method returns ``True`` if the status code of the dendrite is ``403``,\nwhich is the HTTP status code for a forbidden request.\n\nReturns:\n    bool: ``True`` if dendrite's status code is ``403``, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "failed_verification": {
    "name": "failed_verification",
    "docstring": "Checks if the dendrite's status code indicates failed verification.\n\nThis method returns ``True`` if the status code of the dendrite is ``401``,\nwhich is the HTTP status code for unauthorized access.\n\nReturns:\n    bool: ``True`` if dendrite's status code is ``401``, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "get_required_fields": {
    "name": "get_required_fields",
    "docstring": "Get the required fields from the model's JSON schema.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "to_headers": {
    "name": "to_headers",
    "docstring": "Converts the state of a Synapse instance into a dictionary of HTTP headers.\n\nThis method is essential for\npackaging Synapse data for network transmission in the Bittensor framework, ensuring that each key aspect of\nthe Synapse is represented in a format suitable for HTTP communication.\n\nProcess:\n\n1. Basic Information: It starts by including the ``name`` and ``timeout`` of the Synapse, which are fundamental for identifying the query and managing its lifespan on the network.\n2. Complex Objects: The method serializes the ``axon`` and ``dendrite`` objects, if present, into strings. This serialization is crucial for preserving the state and structure of these objects over the network.\n3. Encoding: Non-optional complex objects are serialized and encoded in base64, making them safe for HTTP transport.\n4. Size Metrics: The method calculates and adds the size of headers and the total object size, providing valuable information for network bandwidth management.\n\nExample Usage::\n\n    synapse = Synapse(name=\"ExampleSynapse\", timeout=30)\n    headers = synapse.to_headers()\n    # headers now contains a dictionary representing the Synapse instance\n\nReturns:\n    dict: A dictionary containing key-value pairs representing the Synapse's properties, suitable for HTTP communication.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "body_hash": {
    "name": "body_hash",
    "docstring": "Computes a SHA3-256 hash of the serialized body of the Synapse instance.\n\nThis hash is used to\nensure the data integrity and security of the Synapse instance when it's transmitted across the\nnetwork. It is a crucial feature for verifying that the data received is the same as the data sent.\n\nProcess:\n\n1. Iterates over each required field as specified in ``required_hash_fields``.\n2. Concatenates the string representation of these fields.\n3. Applies SHA3-256 hashing to the concatenated string to produce a unique fingerprint of the data.\n\nExample::\n\n    synapse = Synapse(name=\"ExampleRoute\", timeout=10)\n    hash_value = synapse.body_hash\n    # hash_value is the SHA3-256 hash of the serialized body of the Synapse instance\n\nReturns:\n    str: The SHA3-256 hash as a hexadecimal string, providing a fingerprint of the Synapse instance's data for integrity checks.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "parse_headers_to_inputs": {
    "name": "parse_headers_to_inputs",
    "docstring": "Interprets and transforms a given dictionary of headers into a structured dictionary, facilitating the reconstruction of Synapse objects.\n\nThis method is essential for parsing network-transmitted\ndata back into a Synapse instance, ensuring data consistency and integrity.\n\nProcess:\n\n1. Separates headers into categories based on prefixes (``axon``, ``dendrite``, etc.).\n2. Decodes and deserializes ``input_obj`` headers into their original objects.\n3. Assigns simple fields directly from the headers to the input dictionary.\n\nExample::\n\n    received_headers = {\n        'bt_header_axon_address': '127.0.0.1',\n        'bt_header_dendrite_port': '8080',\n        # Other headers...\n    }\n    inputs = Synapse.parse_headers_to_inputs(received_headers)\n    # inputs now contains a structured representation of Synapse properties based on the headers\n\nNote:\n    This is handled automatically when calling :func:`Synapse.from_headers(headers)` and does not need to be called directly.\n\nArgs:\n    headers (dict): The headers dictionary to parse.\n\nReturns:\n    dict: A structured dictionary representing the inputs for constructing a Synapse instance.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "headers",
        "type": "dict"
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "from_headers": {
    "name": "from_headers",
    "docstring": "Constructs a new Synapse instance from a given headers dictionary, enabling the re-creation of the Synapse's state as it was prior to network transmission.\n\nThis method is a key part of the\ndeserialization process in the Bittensor network, allowing nodes to accurately reconstruct Synapse\nobjects from received data.\n\nExample::\n\n    received_headers = {\n        'bt_header_axon_address': '127.0.0.1',\n        'bt_header_dendrite_port': '8080',\n        # Other headers...\n    }\n    synapse = Synapse.from_headers(received_headers)\n    # synapse is a new Synapse instance reconstructed from the received headers\n\nArgs:\n    headers (dict): The dictionary of headers containing serialized Synapse information.\n\nReturns:\n    Synapse: A new instance of Synapse, reconstructed from the parsed header information, replicating the original instance's state.",
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "headers",
        "type": "dict"
      }
    ],
    "returns": "'Synapse'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/synapse.py"
  },
  "convert_type_string": {
    "name": "convert_type_string",
    "docstring": null,
    "parameters": [
      {
        "name": "_",
        "type": null
      },
      {
        "name": "name",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "determine_chain_endpoint_and_network": {
    "name": "determine_chain_endpoint_and_network",
    "docstring": "Determines the chain endpoint and network from the passed network or chain_endpoint.\n\nArgs:\n    network (str): The network flag. The choices are: ``-- finney`` (main network), ``-- archive``\n        (archive network +300 blocks), ``-- local`` (local running network), ``-- test`` (test network).\nReturns:\n    network (str): The network flag.\n    chain_endpoint (str): The chain endpoint flag. If set, overrides the ``network`` argument.",
    "parameters": [
      {
        "name": "network",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "setup_config": {
    "name": "setup_config",
    "docstring": "Sets up and returns the configuration for the Subtensor network and endpoint.\n\nThis method determines the appropriate network and chain endpoint based on the provided network string or\nconfiguration object. It evaluates the network and endpoint in the following order of precedence:\n1. Provided network string.\n2. Configured chain endpoint in the `config` object.\n3. Configured network in the `config` object.\n4. Default chain endpoint.\n5. Default network.\n\nArgs:\n    network (str): The name of the Subtensor network. If None, the network and endpoint will be determined from\n        the `config` object.\n    config (bittensor.config): The configuration object containing the network and chain endpoint settings.\n\nReturns:\n    tuple: A tuple containing the formatted WebSocket endpoint URL and the evaluated network name.",
    "parameters": [
      {
        "name": "network",
        "type": "str"
      },
      {
        "name": "config",
        "type": "'bittensor.config'"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "close": {
    "name": "close",
    "docstring": "Cleans up resources for this subtensor instance like active websocket connection and active extensions.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "nominate": {
    "name": "nominate",
    "docstring": "Becomes a delegate for the hotkey associated with the given wallet. This method is used to nominate\na neuron (identified by the hotkey in the wallet) as a delegate on the Bittensor network, allowing it\nto participate in consensus and validation processes.\n\nArgs:\n    wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.\n    wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the\n        blockchain.\n    wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.\n\nReturns:\n    bool: ``True`` if the nomination process is successful, ``False`` otherwise.\n\nThis function is a key part of the decentralized governance mechanism of Bittensor, allowing for the\ndynamic selection and participation of validators in the network's consensus process.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "delegate": {
    "name": "delegate",
    "docstring": "Becomes a delegate for the hotkey associated with the given wallet. This method is used to nominate\na neuron (identified by the hotkey in the wallet) as a delegate on the Bittensor network, allowing it\nto participate in consensus and validation processes.\n\nArgs:\n    wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.\n    delegate_ss58 (Optional[str]): The ``SS58`` address of the delegate neuron.\n    amount (Union[Balance, float]): The amount of TAO to undelegate.\n    wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the\n        blockchain.\n    wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the nomination process is successful, False otherwise.\n\nThis function is a key part of the decentralized governance mechanism of Bittensor, allowing for the\ndynamic selection and participation of validators in the network's consensus process.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "undelegate": {
    "name": "undelegate",
    "docstring": "Removes a specified amount of stake from a delegate neuron using the provided wallet. This action\nreduces the staked amount on another neuron, effectively withdrawing support or speculation.\n\nArgs:\n    wallet (bittensor.wallet): The wallet used for the undelegation process.\n    delegate_ss58 (Optional[str]): The ``SS58`` address of the delegate neuron.\n    amount (Union[Balance, float]): The amount of TAO to undelegate.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the undelegation is successful, False otherwise.\n\nThis function reflects the dynamic and speculative nature of the Bittensor network, allowing neurons\nto adjust their stakes and investments based on changing perceptions and performances within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "set_take": {
    "name": "set_take",
    "docstring": "Set delegate hotkey take\nArgs:\n    wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.\n    delegate_ss58 (str, optional): Hotkey\n    take (float): Delegate take on subnet ID\n    wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the\n        blockchain.\n    wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.\n\nReturns:\n    bool: ``True`` if the process is successful, False otherwise.\n\nThis function is a key part of the decentralized governance mechanism of Bittensor, allowing for the\ndynamic selection and participation of validators in the network's consensus process.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "take",
        "type": "float"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "send_extrinsic": {
    "name": "send_extrinsic",
    "docstring": "Sends an extrinsic to the Bittensor blockchain using the provided wallet and parameters. This method\nconstructs and submits the extrinsic, handling retries and blockchain communication.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the extrinsic.\n    module (str): The module name for the extrinsic.\n    function (str): The function name for the extrinsic.\n    params (dict): The parameters for the extrinsic.\n    period (int, optional): The number of blocks for the extrinsic to live in the mempool. Defaults to 5.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    max_retries (int, optional): The maximum number of retries for the extrinsic. Defaults to 3.\n    wait_time (int, optional): The wait time between retries. Defaults to 3.\n    max_wait (int, optional): The maximum wait time for the extrinsic. Defaults to 20.\n\nReturns:\n    Optional[ExtrinsicReceipt]: The receipt of the extrinsic if successful, None otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "module",
        "type": "str"
      },
      {
        "name": "function",
        "type": "str"
      },
      {
        "name": "params",
        "type": "dict"
      },
      {
        "name": "period",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "max_retries",
        "type": "int"
      },
      {
        "name": "wait_time",
        "type": "int"
      },
      {
        "name": "max_wait",
        "type": "int"
      }
    ],
    "returns": "Optional[ExtrinsicReceipt]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "set_weights": {
    "name": "set_weights",
    "docstring": "Sets the inter-neuronal weights for the specified neuron. This process involves specifying the\ninfluence or trust a neuron places on other neurons in the network, which is a fundamental aspect\nof Bittensor's decentralized learning architecture.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.\n    netuid (int): The unique identifier of the subnet.\n    uids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs that the weights are being\n        set for.\n    weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each\n        UID.\n    version_key (int, optional): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n    max_retries (int, optional): The number of maximum attempts to set weights. (Default: 5)\n\nReturns:\n    Tuple[bool, str]: ``True`` if the setting of weights is successful, False otherwise. And `msg`, a string\n    value describing the success or potential error.\n\nThis function is crucial in shaping the network's collective intelligence, where each neuron's\nlearning and contribution are influenced by the weights it sets towards others\u301081\u2020source\u3011.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], 'torch.LongTensor', list]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor', list]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_retries",
        "type": "int"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_set_weights": {
    "name": "_do_set_weights",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "int"
      },
      {
        "name": "vals",
        "type": "List[int]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "commit_weights": {
    "name": "commit_weights",
    "docstring": "Commits a hash of the neuron's weights to the Bittensor blockchain using the provided wallet.\nThis action serves as a commitment or snapshot of the neuron's current weight distribution.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron committing the weights.\n    netuid (int): The unique identifier of the subnet.\n    salt (List[int]): list of randomly generated integers as salt to generated weighted hash.\n    uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.\n    weights (np.ndarray): NumPy array of weight values corresponding to each UID.\n    version_key (int, optional): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n    max_retries (int, optional): The number of maximum attempts to commit weights. (Default: 5)\n\nReturns:\n    Tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string\n    value describing the success or potential error.\n\nThis function allows neurons to create a tamper-proof record of their weight distribution at a specific point in time,\nenhancing transparency and accountability within the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "salt",
        "type": "List[int]"
      },
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], list]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.int64], list]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_retries",
        "type": "int"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_commit_weights": {
    "name": "_do_commit_weights",
    "docstring": "Internal method to send a transaction to the Bittensor blockchain, committing the hash of a neuron's weights.\nThis method constructs and submits the transaction, handling retries and blockchain communication.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron committing the weights.\n    netuid (int): The unique identifier of the subnet.\n    commit_hash (str): The hash of the neuron's weights to be committed.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n\nReturns:\n    Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.\n\nThis method ensures that the weight commitment is securely recorded on the Bittensor blockchain, providing a\nverifiable record of the neuron's weight distribution at a specific point in time.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "commit_hash",
        "type": "str"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "reveal_weights": {
    "name": "reveal_weights",
    "docstring": "Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.\nThis action serves as a revelation of the neuron's previously committed weight distribution.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron revealing the weights.\n    netuid (int): The unique identifier of the subnet.\n    uids (np.ndarray): NumPy array of neuron UIDs for which weights are being revealed.\n    weights (np.ndarray): NumPy array of weight values corresponding to each UID.\n    salt (np.ndarray): NumPy array of salt values corresponding to the hash function.\n    version_key (int, optional): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n    max_retries (int, optional): The number of maximum attempts to reveal weights. (Default: 5)\n\nReturns:\n    Tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string\n    value describing the success or potential error.\n\nThis function allows neurons to reveal their previously committed weight distribution, ensuring transparency\nand accountability within the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], list]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.int64], list]"
      },
      {
        "name": "salt",
        "type": "Union[NDArray[np.int64], list]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_retries",
        "type": "int"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_reveal_weights": {
    "name": "_do_reveal_weights",
    "docstring": "Internal method to send a transaction to the Bittensor blockchain, revealing the weights for a specific subnet.\nThis method constructs and submits the transaction, handling retries and blockchain communication.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron revealing the weights.\n    netuid (int): The unique identifier of the subnet.\n    uids (List[int]): List of neuron UIDs for which weights are being revealed.\n    values (List[int]): List of weight values corresponding to each UID.\n    salt (List[int]): List of salt values corresponding to the hash function.\n    version_key (int): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n\nReturns:\n    Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.\n\nThis method ensures that the weight revelation is securely recorded on the Bittensor blockchain, providing transparency\nand accountability for the neuron's weight distribution.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "values",
        "type": "List[int]"
      },
      {
        "name": "salt",
        "type": "List[int]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "register": {
    "name": "register",
    "docstring": "Registers a neuron on the Bittensor network using the provided wallet. Registration\nis a critical step for a neuron to become an active participant in the network, enabling\nit to stake, set weights, and receive incentives.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron to be registered.\n    netuid (int): The unique identifier of the subnet.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n        Defaults to `False`.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n         Defaults to `True`.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n    max_allowed_attempts (int): Maximum number of attempts to register the wallet.\n    output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning\n        the progress is printed on the same lines. Defaults to `True`.\n    cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.\n    dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).\n    tpb (int): The number of threads per block (CUDA). Default to `256`.\n    num_processes (Optional[int]): The number of processes to use to register. Default to `None`.\n    update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.\n    log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.\n\nReturns:\n    bool: ``True`` if the registration is successful, False otherwise.\n\nThis function facilitates the entry of new neurons into the network, supporting the decentralized\ngrowth and scalability of the Bittensor ecosystem.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_allowed_attempts",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "cuda",
        "type": "bool"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "num_processes",
        "type": "Optional[int]"
      },
      {
        "name": "update_interval",
        "type": "Optional[int]"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "swap_hotkey": {
    "name": "swap_hotkey",
    "docstring": "Swaps an old hotkey with a new hotkey for the specified wallet.\n\nThis method initiates an extrinsic to change the hotkey associated with a wallet to a new hotkey. It provides\noptions to wait for inclusion and finalization of the transaction, and to prompt the user for confirmation.\n\nArgs:\n    wallet (bittensor.wallet): The wallet whose hotkey is to be swapped.\n    new_wallet (bittensor.wallet): The new wallet with the hotkey to be set.\n    wait_for_inclusion (bool): Whether to wait for the transaction to be included in a block.\n        Default is `False`.\n    wait_for_finalization (bool): Whether to wait for the transaction to be finalized. Default is `True`.\n    prompt (bool): Whether to prompt the user for confirmation before proceeding. Default is `False`.\n\nReturns:\n    bool: True if the hotkey swap was successful, False otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "new_wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "run_faucet": {
    "name": "run_faucet",
    "docstring": "Facilitates a faucet transaction, allowing new neurons to receive an initial amount of TAO\nfor participating in the network. This function is particularly useful for newcomers to the\nBittensor network, enabling them to start with a small stake on testnet only.\n\nArgs:\n    wallet (bittensor.wallet): The wallet for which the faucet transaction is to be run.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n        Defaults to `False`.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n         Defaults to `True`.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n    max_allowed_attempts (int): Maximum number of attempts to register the wallet.\n    output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning\n        the progress is printed on the same lines. Defaults to `True`.\n    cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.\n    dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).\n    tpb (int): The number of threads per block (CUDA). Default to `256`.\n    num_processes (Optional[int]): The number of processes to use to register. Default to `None`.\n    update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.\n    log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.\n\nReturns:\n    bool: ``True`` if the faucet transaction is successful, False otherwise.\n\nThis function is part of Bittensor's onboarding process, ensuring that new neurons have\nthe necessary resources to begin their journey in the decentralized AI network.\n\nNote:\n    This is for testnet ONLY and is disabled currently. You must build your own staging subtensor chain with the\n    ``--features pow-faucet`` argument to enable this.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_allowed_attempts",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "cuda",
        "type": "bool"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "num_processes",
        "type": "Optional[int]"
      },
      {
        "name": "update_interval",
        "type": "Optional[int]"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "burned_register": {
    "name": "burned_register",
    "docstring": "Registers a neuron on the Bittensor network by recycling TAO. This method of registration\ninvolves recycling TAO tokens, allowing them to be re-mined by performing work on the network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron to be registered.\n    netuid (int): The unique identifier of the subnet.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n        Defaults to `False`.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n        Defaults to `True`.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding. Defaults to `False`.\n\nReturns:\n    bool: ``True`` if the registration is successful, False otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_pow_register": {
    "name": "_do_pow_register",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "pow_result",
        "type": "'POWSolution'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_burned_register": {
    "name": "_do_burned_register",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_swap_hotkey": {
    "name": "_do_swap_hotkey",
    "docstring": "Performs a hotkey swap extrinsic call to the Subtensor chain.\n\nArgs:\n    wallet (bittensor.wallet): The wallet whose hotkey is to be swapped.\n    new_wallet (bittensor.wallet): The wallet with the new hotkey to be set.\n    wait_for_inclusion (bool): Whether to wait for the transaction to be included in a block. Default is\n    `False`.\n    wait_for_finalization (bool): Whether to wait for the transaction to be finalized. Default is `True`.\n\nReturns:\n    Tuple[bool, Optional[str]]: A tuple containing a boolean indicating success or failure, and an optional\n        error message.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "new_wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "transfer": {
    "name": "transfer",
    "docstring": "Executes a transfer of funds from the provided wallet to the specified destination address.\nThis function is used to move TAO tokens within the Bittensor network, facilitating transactions\nbetween neurons.\n\nArgs:\n    wallet (bittensor.wallet): The wallet from which funds are being transferred.\n    dest (str): The destination public key address.\n    amount (Union[Balance, float]): The amount of TAO to be transferred.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    transfer_extrinsic (bool): ``True`` if the transfer is successful, False otherwise.\n\nThis function is essential for the fluid movement of tokens in the network, supporting\nvarious economic activities such as staking, delegation, and reward distribution.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "dest",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "Union[Balance, float]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_transfer_fee": {
    "name": "get_transfer_fee",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "dest",
        "type": "str"
      },
      {
        "name": "value",
        "type": "Union['Balance', float, int]"
      }
    ],
    "returns": "'Balance'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_transfer": {
    "name": "_do_transfer",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "dest",
        "type": "str"
      },
      {
        "name": "transfer_balance",
        "type": "'Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str], Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_existential_deposit": {
    "name": "get_existential_deposit",
    "docstring": "Retrieves the existential deposit amount for the Bittensor blockchain. The existential deposit\nis the minimum amount of TAO required for an account to exist on the blockchain. Accounts with\nbalances below this threshold can be reaped to conserve network resources.\n\nArgs:\n    block (Optional[int]): Block number at which to query the deposit amount. If ``None``, the current block is\n        used.\n\nReturns:\n    Optional[Balance]: The existential deposit amount, or ``None`` if the query fails.\n\nThe existential deposit is a fundamental economic parameter in the Bittensor network, ensuring\nefficient use of storage and preventing the proliferation of dust accounts.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "register_subnetwork": {
    "name": "register_subnetwork",
    "docstring": "Registers a new subnetwork on the Bittensor network using the provided wallet. This function\nis used for the creation and registration of subnetworks, which are specialized segments of the\noverall Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet to be used for registration.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the subnetwork registration is successful, False otherwise.\n\nThis function allows for the expansion and diversification of the Bittensor network, supporting\nits decentralized and adaptable architecture.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": null
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "set_hyperparameter": {
    "name": "set_hyperparameter",
    "docstring": "Sets a specific hyperparameter for a given subnetwork on the Bittensor blockchain. This action\ninvolves adjusting network-level parameters, influencing the behavior and characteristics of the\nsubnetwork.\n\nArgs:\n    wallet (bittensor.wallet): The wallet used for setting the hyperparameter.\n    netuid (int): The unique identifier of the subnetwork.\n    parameter (str): The name of the hyperparameter to be set.\n    value: The new value for the hyperparameter.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the hyperparameter setting is successful, False otherwise.\n\nThis function plays a critical role in the dynamic governance and adaptability of the Bittensor\nnetwork, allowing for fine-tuning of network operations and characteristics.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "parameter",
        "type": "str"
      },
      {
        "name": "value",
        "type": null
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": null
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "serve_axon": {
    "name": "serve_axon",
    "docstring": "Registers an Axon serving endpoint on the Bittensor network for a specific neuron. This function\nis used to set up the Axon, a key component of a neuron that handles incoming queries and data\nprocessing tasks.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    axon (bittensor.Axon): The Axon instance to be registered for serving.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n\nReturns:\n    bool: ``True`` if the Axon serve registration is successful, False otherwise.\n\nBy registering an Axon, the neuron becomes an active part of the network's distributed\ncomputing infrastructure, contributing to the collective intelligence of Bittensor.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "axon",
        "type": "'bittensor.axon'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_serve_axon": {
    "name": "_do_serve_axon",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "call_params",
        "type": "'AxonServeCallParams'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "serve_prometheus": {
    "name": "serve_prometheus",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "port",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_serve_prometheus": {
    "name": "_do_serve_prometheus",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "call_params",
        "type": "'PrometheusServeCallParams'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_associate_ips": {
    "name": "_do_associate_ips",
    "docstring": "Sends an associate IPs extrinsic to the chain.\n\nArgs:\n    wallet (:func:`bittensor.wallet`): Wallet object.\n    ip_info_list (:func:`List[IPInfo]`): List of IPInfo objects.\n    netuid (int): Netuid to associate IPs to.\n    wait_for_inclusion (bool): If ``true``, waits for inclusion.\n    wait_for_finalization (bool): If ``true``, waits for finalization.\n\nReturns:\n    success (bool): ``True`` if associate IPs was successful.\n    error (:func:`Optional[str]`): Error message if associate IPs failed, None otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "ip_info_list",
        "type": "List['IPInfo']"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "add_stake": {
    "name": "add_stake",
    "docstring": "Adds the specified amount of stake to a neuron identified by the hotkey ``SS58`` address. Staking\nis a fundamental process in the Bittensor network that enables neurons to participate actively\nand earn incentives.\n\nArgs:\n    wallet (bittensor.wallet): The wallet to be used for staking.\n    hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey associated with the neuron.\n    amount (Union[Balance, float]): The amount of TAO to stake.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the staking is successful, False otherwise.\n\nThis function enables neurons to increase their stake in the network, enhancing their influence\nand potential rewards in line with Bittensor's consensus and reward mechanisms.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union['Balance', float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "add_stake_multiple": {
    "name": "add_stake_multiple",
    "docstring": "Adds stakes to multiple neurons identified by their hotkey SS58 addresses. This bulk operation\nallows for efficient staking across different neurons from a single wallet.\n\nArgs:\n    wallet (bittensor.wallet): The wallet used for staking.\n    hotkey_ss58s (List[str]): List of ``SS58`` addresses of hotkeys to stake to.\n    amounts (List[Union[Balance, float]], optional): Corresponding amounts of TAO to stake for each hotkey.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the staking is successful for all specified neurons, False otherwise.\n\nThis function is essential for managing stakes across multiple neurons, reflecting the dynamic\nand collaborative nature of the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58s",
        "type": "List[str]"
      },
      {
        "name": "amounts",
        "type": "Optional[List[Union['Balance', float]]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_stake": {
    "name": "_do_stake",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "unstake_multiple": {
    "name": "unstake_multiple",
    "docstring": "Performs batch unstaking from multiple hotkey accounts, allowing a neuron to reduce its staked amounts\nefficiently. This function is useful for managing the distribution of stakes across multiple neurons.\n\nArgs:\n    wallet (bittensor.wallet): The wallet linked to the coldkey from which the stakes are being withdrawn.\n    hotkey_ss58s (List[str]): A list of hotkey ``SS58`` addresses to unstake from.\n    amounts (List[Union[Balance, float]], optional): The amounts of TAO to unstake from each hotkey. If not\n        provided, unstakes all available stakes.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the batch unstaking is successful, False otherwise.\n\nThis function allows for strategic reallocation or withdrawal of stakes, aligning with the dynamic\nstake management aspect of the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58s",
        "type": "List[str]"
      },
      {
        "name": "amounts",
        "type": "Optional[List[Union['Balance', float]]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "unstake": {
    "name": "unstake",
    "docstring": "Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting\nindividual neuron stakes within the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.\n    hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey account to unstake from.\n    amount (Union[Balance, float], optional): The amount of TAO to unstake. If not specified, unstakes all.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the unstaking process is successful, False otherwise.\n\nThis function supports flexible stake management, allowing neurons to adjust their network participation\nand potential reward accruals.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union['Balance', float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_unstake": {
    "name": "_do_unstake",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "check_in_arbitration": {
    "name": "check_in_arbitration",
    "docstring": "Checks storage function to see if the provided coldkey is in arbitration.\nIf 0, `swap` has not been called on this key. If 1, swap has been called once, so\nthe key is not in arbitration. If >1, `swap` has been called with multiple destinations, and\nthe key is thus in arbitration.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "ss58_address",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_remaining_arbitration_period": {
    "name": "get_remaining_arbitration_period",
    "docstring": "Retrieves the remaining arbitration period for a given coldkey.\nArgs:\n    coldkey_ss58 (str): The SS58 address of the coldkey.\n    block (Optional[int], optional): The block number to query. If None, uses the latest block.\nReturns:\n    Optional[int]: The remaining arbitration period in blocks, or 0 if not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "register_senate": {
    "name": "register_senate",
    "docstring": "Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting\nindividual neuron stakes within the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the unstaking process is successful, False otherwise.\n\nThis function supports flexible stake management, allowing neurons to adjust their network participation\nand potential reward accruals.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "leave_senate": {
    "name": "leave_senate",
    "docstring": "Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting\nindividual neuron stakes within the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the unstaking process is successful, False otherwise.\n\nThis function supports flexible stake management, allowing neurons to adjust their network participation\nand potential reward accruals.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "vote_senate": {
    "name": "vote_senate",
    "docstring": "Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting\nindividual neuron stakes within the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.\n    proposal_hash (str): The hash of the proposal being voted on.\n    proposal_idx (int): The index of the proposal being voted on.\n    vote (bool): The vote to be cast (True for yes, False for no).\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the unstaking process is successful, False otherwise.\n\nThis function supports flexible stake management, allowing neurons to adjust their network participation\nand potential reward accruals.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "proposal_hash",
        "type": "str"
      },
      {
        "name": "proposal_idx",
        "type": "int"
      },
      {
        "name": "vote",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "is_senate_member": {
    "name": "is_senate_member",
    "docstring": "Checks if a given neuron (identified by its hotkey SS58 address) is a member of the Bittensor senate.\nThe senate is a key governance body within the Bittensor network, responsible for overseeing and\napproving various network operations and proposals.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int]): The blockchain block number at which to check senate membership.\n\nReturns:\n    bool: ``True`` if the neuron is a senate member at the given block, False otherwise.\n\nThis function is crucial for understanding the governance dynamics of the Bittensor network and for\nidentifying the neurons that hold decision-making power within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_vote_data": {
    "name": "get_vote_data",
    "docstring": "Retrieves the voting data for a specific proposal on the Bittensor blockchain. This data includes\ninformation about how senate members have voted on the proposal.\n\nArgs:\n    proposal_hash (str): The hash of the proposal for which voting data is requested.\n    block (Optional[int]): The blockchain block number to query the voting data.\n\nReturns:\n    Optional[ProposalVoteData]: An object containing the proposal's voting data, or ``None`` if not found.\n\nThis function is important for tracking and understanding the decision-making processes within\nthe Bittensor network, particularly how proposals are received and acted upon by the governing body.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "proposal_hash",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[ProposalVoteData]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_senate_members": {
    "name": "get_senate_members",
    "docstring": "Retrieves the list of current senate members from the Bittensor blockchain. Senate members are\nresponsible for governance and decision-making within the network.\n\nArgs:\n    block (Optional[int]): The blockchain block number at which to retrieve the senate members.\n\nReturns:\n    Optional[List[str]]: A list of ``SS58`` addresses of current senate members, or ``None`` if not available.\n\nUnderstanding the composition of the senate is key to grasping the governance structure and\ndecision-making authority within the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[List[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_proposal_call_data": {
    "name": "get_proposal_call_data",
    "docstring": "Retrieves the call data of a specific proposal on the Bittensor blockchain. This data provides\ndetailed information about the proposal, including its purpose and specifications.\n\nArgs:\n    proposal_hash (str): The hash of the proposal.\n    block (Optional[int]): The blockchain block number at which to query the proposal call data.\n\nReturns:\n    Optional[GenericCall]: An object containing the proposal's call data, or ``None`` if not found.\n\nThis function is crucial for analyzing the types of proposals made within the network and the\nspecific changes or actions they intend to implement or address.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "proposal_hash",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['GenericCall']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_proposal_hashes": {
    "name": "get_proposal_hashes",
    "docstring": "Retrieves the list of proposal hashes currently present on the Bittensor blockchain. Each hash\nuniquely identifies a proposal made within the network.\n\nArgs:\n    block (Optional[int]): The blockchain block number to query the proposal hashes.\n\nReturns:\n    Optional[List[str]]: A list of proposal hashes, or ``None`` if not available.\n\nThis function enables tracking and reviewing the proposals made in the network, offering insights\ninto the active governance and decision-making processes.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[List[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_proposals": {
    "name": "get_proposals",
    "docstring": "Retrieves all active proposals on the Bittensor blockchain, along with their call and voting data.\nThis comprehensive view allows for a thorough understanding of the proposals and their reception\nby the senate.\n\nArgs:\n    block (Optional[int]): The blockchain block number to query the proposals.\n\nReturns:\n    Optional[Dict[str, Tuple[bittensor.ProposalCallData, bittensor.ProposalVoteData]]]: A dictionary mapping\n        proposal hashes to their corresponding call and vote data, or ``None`` if not available.\n\nThis function is integral for analyzing the governance activity on the Bittensor network,\nproviding a holistic view of the proposals and their impact or potential changes within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Dict[str, Tuple['GenericCall', 'ProposalVoteData']]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "root_register": {
    "name": "root_register",
    "docstring": "Registers the neuron associated with the wallet on the root network. This process is integral for\nparticipating in the highest layer of decision-making and governance within the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron to be registered on the root network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the registration on the root network is successful, False otherwise.\n\nThis function enables neurons to engage in the most critical and influential aspects of the network's\ngovernance, signifying a high level of commitment and responsibility in the Bittensor ecosystem.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_root_register": {
    "name": "_do_root_register",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "root_set_weights": {
    "name": "root_set_weights",
    "docstring": "Sets the weights for neurons on the root network. This action is crucial for defining the influence\nand interactions of neurons at the root level of the Bittensor network.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.\n    netuids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs for which weights are\n        being set.\n    weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each\n        UID.\n    version_key (int, optional): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\n\nReturns:\n    bool: ``True`` if the setting of root-level weights is successful, False otherwise.\n\nThis function plays a pivotal role in shaping the root network's collective intelligence and decision-making\nprocesses, reflecting the principles of decentralized governance and collaborative learning in Bittensor.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuids",
        "type": "Union[NDArray[np.int64], 'torch.LongTensor', list]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor', list]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_set_root_weights": {
    "name": "_do_set_root_weights",
    "docstring": "Internal method to send a transaction to the Bittensor blockchain, setting weights\nfor specified neurons on root. This method constructs and submits the transaction, handling\nretries and blockchain communication.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.\n    uids (List[int]): List of neuron UIDs for which weights are being set.\n    vals (List[int]): List of weight values corresponding to each UID.\n    netuid (int): Unique identifier for the network.\n    version_key (int, optional): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n\nReturns:\n    Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.\n\nThis method is vital for the dynamic weighting mechanism in Bittensor, where neurons adjust their\ntrust in other neurons based on observed performance and contributions on the root network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "vals",
        "type": "List[int]"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "query_identity": {
    "name": "query_identity",
    "docstring": "Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves\ndetailed identity information about a specific neuron, which is a crucial aspect of the network's decentralized\nidentity and governance system.\n\nNOTE:\n    See the `Bittensor CLI documentation <https://docs.bittensor.com/reference/btcli>`_ for supported identity\n    parameters.\n\nArgs:\n    key (str): The key used to query the neuron's identity, typically the neuron's ``SS58`` address.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    result (dict): An object containing the identity information of the neuron if found, ``None`` otherwise.\n\nThe identity information can include various attributes such as the neuron's stake, rank, and other\nnetwork-specific details, providing insights into the neuron's role and status within the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "key",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "update_identity": {
    "name": "update_identity",
    "docstring": "Updates the identity of a neuron on the Bittensor blockchain. This function allows neurons to modify their\nidentity attributes, reflecting changes in their roles, stakes, or other network-specific parameters.\n\nNOTE:\n    See the `Bittensor CLI documentation <https://docs.bittensor.com/reference/btcli>`_ for supported identity\n    parameters.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron whose identity is being updated.\n    identified (str, optional): The identified ``SS58`` address of the neuron. Defaults to the wallet's coldkey\n        address.\n    params (dict, optional): A dictionary of parameters to update in the neuron's identity.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n\nReturns:\n    bool: ``True`` if the identity update is successful, False otherwise.\n\nThis function plays a vital role in maintaining the accuracy and currency of neuron identities in the\nBittensor network, ensuring that the network's governance and consensus mechanisms operate effectively.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "identified",
        "type": "Optional[str]"
      },
      {
        "name": "params",
        "type": "Optional[dict]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "commit": {
    "name": "commit",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "data",
        "type": "str"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_commitment": {
    "name": "get_commitment",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "query_subtensor": {
    "name": "query_subtensor",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      },
      {
        "name": "params",
        "type": "Optional[List[object]]"
      }
    ],
    "returns": "MockSubtensorValue",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "query_map_subtensor": {
    "name": "query_map_subtensor",
    "docstring": "Note: Double map requires one param",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      },
      {
        "name": "params",
        "type": "Optional[List[object]]"
      }
    ],
    "returns": "Optional[MockMapResult]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "query_constant": {
    "name": "query_constant",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "module_name",
        "type": "str"
      },
      {
        "name": "constant_name",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[object]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "query_module": {
    "name": "query_module",
    "docstring": "Queries any module storage on the Bittensor blockchain with the specified parameters and block number.\nThis function is a generic query interface that allows for flexible and diverse data retrieval from\nvarious blockchain modules.\n\nArgs:\n    module (str): The name of the module from which to query data.\n    name (str): The name of the storage function within the module.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n    params (Optional[List[object]], optional): A list of parameters to pass to the query function.\n\nReturns:\n    Optional[ScaleType]: An object containing the requested data if found, ``None`` otherwise.\n\nThis versatile query function is key to accessing a wide range of data and insights from different\nparts of the Bittensor blockchain, enhancing the understanding and analysis of the network's state and dynamics.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "module",
        "type": "str"
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      },
      {
        "name": "params",
        "type": "Optional[list]"
      }
    ],
    "returns": "'ScaleType'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "query_map": {
    "name": "query_map",
    "docstring": "Queries map storage from any module on the Bittensor blockchain. This function retrieves data structures\nthat represent key-value mappings, essential for accessing complex and structured data within the blockchain\nmodules.\n\nArgs:\n    module (str): The name of the module from which to query the map storage.\n    name (str): The specific storage function within the module to query.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n    params (Optional[List[object]], optional): Parameters to be passed to the query.\n\nReturns:\n    result (QueryMapResult): A data structure representing the map storage if found, ``None`` otherwise.\n\nThis function is particularly useful for retrieving detailed and structured data from various blockchain\nmodules, offering insights into the network's state and the relationships between its different components.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "module",
        "type": "str"
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      },
      {
        "name": "params",
        "type": "Optional[list]"
      }
    ],
    "returns": "QueryMapResult",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "state_call": {
    "name": "state_call",
    "docstring": "Makes a state call to the Bittensor blockchain, allowing for direct queries of the blockchain's state.\nThis function is typically used for advanced queries that require specific method calls and data inputs.\n\nArgs:\n    method (str): The method name for the state call.\n    data (str): The data to be passed to the method.\n    block (Optional[int]): The blockchain block number at which to perform the state call.\n\nReturns:\n    result (Dict[Any, Any]): The result of the rpc call.\n\nThe state call function provides a more direct and flexible way of querying blockchain data,\nuseful for specific use cases where standard queries are insufficient.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "method",
        "type": "str"
      },
      {
        "name": "data",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Dict[Any, Any]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "query_runtime_api": {
    "name": "query_runtime_api",
    "docstring": "Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying\nruntime and retrieve data encoded in Scale Bytes format. This function is essential for advanced users\nwho need to interact with specific runtime methods and decode complex data types.\n\nArgs:\n    runtime_api (str): The name of the runtime API to query.\n    method (str): The specific method within the runtime API to call.\n    params (Optional[List[ParamWithTypes]], optional): The parameters to pass to the method call.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    Optional[bytes]: The Scale Bytes encoded result from the runtime API call, or ``None`` if the call fails.\n\nThis function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed\nand specific interactions with the network's runtime environment.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "runtime_api",
        "type": "str"
      },
      {
        "name": "method",
        "type": "str"
      },
      {
        "name": "params",
        "type": "Optional[Union[List[int], Dict[str, int]]]"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_encode_params": {
    "name": "_encode_params",
    "docstring": "Returns a hex encoded string of the params using their types.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "call_definition",
        "type": "List['ParamWithTypes']"
      },
      {
        "name": "params",
        "type": "Union[List[Any], Dict[str, Any]]"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_get_hyperparameter": {
    "name": "_get_hyperparameter",
    "docstring": "Retrieves a specified hyperparameter for a specific subnet.\n\nArgs:\n    param_name (str): The name of the hyperparameter to retrieve.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[Union[int, float]]: The value of the specified hyperparameter if the subnet exists, ``None``\n        otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "param_name",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Any]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "rho": {
    "name": "rho",
    "docstring": "Retrieves the 'Rho' hyperparameter for a specified subnet within the Bittensor network. 'Rho' represents the\nglobal inflation rate, which directly influences the network's token emission rate and economic model.\n\nNote:\n    This is currently fixed such that the Bittensor blockchain emmits 7200 Tao per day.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number at which to query the parameter.\n\nReturns:\n    Optional[int]: The value of the 'Rho' hyperparameter if the subnet exists, ``None`` otherwise.\n\nMathematical Context:\n    Rho (p) is calculated based on the network's target inflation and actual neuron staking.\n    It adjusts the emission rate of the TAO token to balance the network's economy and dynamics.\n    The formula for Rho is defined as: p = (Staking_Target / Staking_Actual) * Inflation_Target.\n    Here, Staking_Target and Staking_Actual represent the desired and actual total stakes in the network,\n    while Inflation_Target is the predefined inflation rate goal.\n\n'Rho' is essential for understanding the network's economic dynamics, affecting the reward distribution\nand incentive structures across the network's neurons.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "kappa": {
    "name": "kappa",
    "docstring": "Retrieves the 'Kappa' hyperparameter for a specified subnet. 'Kappa' is a critical parameter in\nthe Bittensor network that controls the distribution of stake weights among neurons, impacting their\nrankings and incentive allocations.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[float]: The value of the 'Kappa' hyperparameter if the subnet exists, None otherwise.\n\nMathematical Context:\n    Kappa (\u03ba) is used in the calculation of neuron ranks, which determine their share of network incentives.\n    It is derived from the softmax function applied to the inter-neuronal weights set by each neuron.\n    The formula for Kappa is: \u03ba_i = exp(w_i) / \u03a3(exp(w_j)), where w_i represents the weight set by neuron i,\n    and the denominator is the sum of exponential weights set by all neurons.\n    This mechanism ensures a normalized and probabilistic distribution of ranks based on relative weights.\n\nUnderstanding 'Kappa' is crucial for analyzing stake dynamics and the consensus mechanism within the network,\nas it plays a significant role in neuron ranking and incentive allocation processes.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "difficulty": {
    "name": "difficulty",
    "docstring": "Retrieves the 'Difficulty' hyperparameter for a specified subnet in the Bittensor network.\nThis parameter is instrumental in determining the computational challenge required for neurons\nto participate in consensus and validation processes.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[int]: The value of the 'Difficulty' hyperparameter if the subnet exists, ``None`` otherwise.\n\nThe 'Difficulty' parameter directly impacts the network's security and integrity by setting the\ncomputational effort required for validating transactions and participating in the network's consensus\nmechanism.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "recycle": {
    "name": "recycle",
    "docstring": "Retrieves the 'Burn' hyperparameter for a specified subnet. The 'Burn' parameter represents the\namount of Tao that is effectively recycled within the Bittensor network.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[Balance]: The value of the 'Burn' hyperparameter if the subnet exists, None otherwise.\n\nUnderstanding the 'Burn' rate is essential for analyzing the network registration usage, particularly\nhow it is correlated with user activity and the overall cost of participation in a given subnet.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "immunity_period": {
    "name": "immunity_period",
    "docstring": "Retrieves the 'ImmunityPeriod' hyperparameter for a specific subnet. This parameter defines the\nduration during which new neurons are protected from certain network penalties or restrictions.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[int]: The value of the 'ImmunityPeriod' hyperparameter if the subnet exists, ``None`` otherwise.\n\nThe 'ImmunityPeriod' is a critical aspect of the network's governance system, ensuring that new\nparticipants have a grace period to establish themselves and contribute to the network without facing\nimmediate punitive actions.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_batch_size": {
    "name": "validator_batch_size",
    "docstring": "Returns network ValidatorBatchSize hyper parameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block\n        is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the ValidatorBatchSize hyperparameter, or None if the subnetwork does not exist\n        or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_prune_len": {
    "name": "validator_prune_len",
    "docstring": "Returns network ValidatorPruneLen hyper parameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block\n    is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the ValidatorPruneLen hyperparameter, or None if the subnetwork does not exist\n    or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_logits_divergence": {
    "name": "validator_logits_divergence",
    "docstring": "Returns network ValidatorLogitsDivergence hyper parameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block\n    is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the ValidatorLogitsDivergence hyperparameter, or None if the subnetwork does\n    not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_sequence_length": {
    "name": "validator_sequence_length",
    "docstring": "Returns network ValidatorSequenceLength hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the ValidatorSequenceLength hyperparameter, or ``None`` if the subnetwork does\n        not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_epochs_per_reset": {
    "name": "validator_epochs_per_reset",
    "docstring": "Returns network ValidatorEpochsPerReset hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the ValidatorEpochsPerReset hyperparameter, or ``None`` if the subnetwork does\n        not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_epoch_length": {
    "name": "validator_epoch_length",
    "docstring": "Returns network ValidatorEpochLen hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the ValidatorEpochLen hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "validator_exclude_quantile": {
    "name": "validator_exclude_quantile",
    "docstring": "Returns network ValidatorExcludeQuantile hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the ValidatorExcludeQuantile hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "max_allowed_validators": {
    "name": "max_allowed_validators",
    "docstring": "Returns network ValidatorExcludeQuantile hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the ValidatorExcludeQuantile hyperparameter, or ``None`` if the subnetwork\n        does not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "min_allowed_weights": {
    "name": "min_allowed_weights",
    "docstring": "Returns network MinAllowedWeights hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "max_weight_limit": {
    "name": "max_weight_limit",
    "docstring": "Returns network MaxWeightsLimit hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "adjustment_alpha": {
    "name": "adjustment_alpha",
    "docstring": "Returns network AdjustmentAlpha hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the AdjustmentAlpha hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "bonds_moving_avg": {
    "name": "bonds_moving_avg",
    "docstring": "Returns network BondsMovingAverage hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the BondsMovingAverage hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "scaling_law_power": {
    "name": "scaling_law_power",
    "docstring": "Returns network ScalingLawPower hyper parameter",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "synergy_scaling_law_power": {
    "name": "synergy_scaling_law_power",
    "docstring": "Returns network ScalingLawPower hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[float]: The value of the ScalingLawPower hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "subnetwork_n": {
    "name": "subnetwork_n",
    "docstring": "Returns network SubnetworkN hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the SubnetworkN hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "max_n": {
    "name": "max_n",
    "docstring": "Returns network MaxAllowedUids hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the MaxAllowedUids hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "blocks_since_epoch": {
    "name": "blocks_since_epoch",
    "docstring": "Returns network BlocksSinceEpoch hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the BlocksSinceEpoch hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "blocks_since_last_update": {
    "name": "blocks_since_last_update",
    "docstring": "Returns the number of blocks since the last update for a specific UID in the subnetwork.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    uid (int): The unique identifier of the neuron.\n\nReturns:\n    Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not\n        exist.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uid",
        "type": "int"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "weights_rate_limit": {
    "name": "weights_rate_limit",
    "docstring": "Returns network WeightsSetRateLimit hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n\nReturns:\n    Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "tempo": {
    "name": "tempo",
    "docstring": "Returns network Tempo hyperparameter.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the Tempo hyperparameter, or ``None`` if the subnetwork does not\n        exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_total_stake_for_hotkey": {
    "name": "get_total_stake_for_hotkey",
    "docstring": "Returns the total stake held on a hotkey including delegative.\n\nArgs:\n    ss58_address (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[Balance]: The total stake held on the hotkey, or ``None`` if the hotkey does not\n        exist or the stake is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "ss58_address",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_total_stake_for_coldkey": {
    "name": "get_total_stake_for_coldkey",
    "docstring": "Returns the total stake held on a coldkey.\n\nArgs:\n    ss58_address (str): The SS58 address of the coldkey.\n    block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[Balance]: The total stake held on the coldkey, or ``None`` if the coldkey does not\n        exist or the stake is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "ss58_address",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_stake_for_coldkey_and_hotkey": {
    "name": "get_stake_for_coldkey_and_hotkey",
    "docstring": "Returns the stake under a coldkey - hotkey pairing.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    coldkey_ss58 (str): The SS58 address of the coldkey.\n    block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[Balance]: The stake under the coldkey - hotkey pairing, or ``None`` if the pairing does not\n        exist or the stake is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "coldkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_stake": {
    "name": "get_stake",
    "docstring": "Returns a list of stake tuples (coldkey, balance) for each delegating coldkey including the owner.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to retrieve the stakes from. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    List[Tuple[str, Balance]]: A list of tuples, each containing a coldkey SS58 address and the corresponding\n        balance staked by that coldkey.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[Tuple[str, 'Balance']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "does_hotkey_exist": {
    "name": "does_hotkey_exist",
    "docstring": "Returns true if the hotkey is known by the chain and there are accounts.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to check the hotkey against. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    bool: ``True`` if the hotkey is known by the chain and there are accounts, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_hotkey_owner": {
    "name": "get_hotkey_owner",
    "docstring": "Returns the coldkey owner of the passed hotkey.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to check the hotkey owner against. If ``None``, the latest\n        block is used. Default is ``None``.\n\nReturns:\n    Optional[str]: The SS58 address of the coldkey owner, or ``None`` if the hotkey does not exist or the owner\n        is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_axon_info": {
    "name": "get_axon_info",
    "docstring": "Returns the axon information for this hotkey account.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to retrieve the axon information from. If ``None``, the\n        latest block is used. Default is ``None``.\n\nReturns:\n    Optional[AxonInfo]: An AxonInfo object containing the axon information, or ``None`` if the axon information\n        is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[AxonInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_prometheus_info": {
    "name": "get_prometheus_info",
    "docstring": "Returns the prometheus information for this hotkey account.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    hotkey_ss58 (str): The SS58 address of the hotkey.\n    block (Optional[int], optional): The block number to retrieve the prometheus information from. If ``None``,\n        the latest block is used. Default is ``None``.\n\nReturns:\n    Optional[PrometheusInfo]: A PrometheusInfo object containing the prometheus information, or ``None`` if the\n        prometheus information is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[PrometheusInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "block": {
    "name": "block",
    "docstring": "Returns current chain block.\nReturns:\n    block (int):\n        Current chain block.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "total_issuance": {
    "name": "total_issuance",
    "docstring": "Retrieves the total issuance of the Bittensor network's native token (Tao) as of a specific\nblockchain block. This represents the total amount of currency that has been issued or mined on the network.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number at which to perform the query.\n\nReturns:\n    Balance: The total issuance of TAO, represented as a Balance object.\n\nThe total issuance is a key economic indicator in the Bittensor network, reflecting the overall supply\nof the currency and providing insights into the network's economic health and inflationary trends.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Balance]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "total_stake": {
    "name": "total_stake",
    "docstring": "Retrieves the total amount of TAO staked on the Bittensor network as of a specific blockchain block.\nThis represents the cumulative stake across all neurons in the network, indicating the overall level\nof participation and investment by the network's participants.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number at which to perform the query.\n\nReturns:\n    Balance: The total amount of TAO staked on the network, represented as a Balance object.\n\nThe total stake is an important metric for understanding the network's security, governance dynamics,\nand the level of commitment by its participants. It is also a critical factor in the network's\nconsensus and incentive mechanisms.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Balance]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "serving_rate_limit": {
    "name": "serving_rate_limit",
    "docstring": "Retrieves the serving rate limit for a specific subnet within the Bittensor network.\nThis rate limit determines how often you can change your node's IP address on the blockchain. Expressed in\nnumber of blocks. Applies to both subnet validator and subnet miner nodes. Used when you move your node to a new\nmachine.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int], optional): The blockchain block number at which to perform the query.\n\nReturns:\n    Optional[int]: The serving rate limit of the subnet if it exists, ``None`` otherwise.\n\nThe serving rate limit is a crucial parameter for maintaining network efficiency and preventing\noveruse of resources by individual neurons. It helps ensure a balanced distribution of service\nrequests across the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "tx_rate_limit": {
    "name": "tx_rate_limit",
    "docstring": "Retrieves the transaction rate limit for the Bittensor network as of a specific blockchain block.\nThis rate limit sets the maximum number of transactions that can be processed within a given time frame.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number at which to perform the query.\n\nReturns:\n    Optional[int]: The transaction rate limit of the network, None if not available.\n\nThe transaction rate limit is an essential parameter for ensuring the stability and scalability\nof the Bittensor network. It helps in managing network load and preventing congestion, thereby\nmaintaining efficient and timely transaction processing.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "subnet_exists": {
    "name": "subnet_exists",
    "docstring": "Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int], optional): The blockchain block number at which to check the subnet's existence.\n\nReturns:\n    bool: ``True`` if the subnet exists, False otherwise.\n\nThis function is critical for verifying the presence of specific subnets in the network,\nenabling a deeper understanding of the network's structure and composition.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_all_subnet_netuids": {
    "name": "get_all_subnet_netuids",
    "docstring": "Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number at which to retrieve the subnet netuids.\n\nReturns:\n    List[int]: A list of subnet netuids.\n\nThis function provides a comprehensive view of the subnets within the Bittensor network,\noffering insights into its diversity and scale.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_total_subnets": {
    "name": "get_total_subnets",
    "docstring": "Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    int: The total number of subnets in the network.\n\nUnderstanding the total number of subnets is essential for assessing the network's growth and\nthe extent of its decentralized infrastructure.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnet_modality": {
    "name": "get_subnet_modality",
    "docstring": "Returns the NetworkModality hyperparameter for a specific subnetwork.\n\nArgs:\n    netuid (int): The unique identifier of the subnetwork.\n    block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.\n\nReturns:\n    Optional[int]: The value of the NetworkModality hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnet_connection_requirement": {
    "name": "get_subnet_connection_requirement",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid_0",
        "type": "int"
      },
      {
        "name": "netuid_1",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_emission_value_by_subnet": {
    "name": "get_emission_value_by_subnet",
    "docstring": "Retrieves the emission value of a specific subnet within the Bittensor network. The emission value\nrepresents the rate at which the subnet emits or distributes the network's native token (Tao).\n\nArgs:\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Optional[float]: The emission value of the subnet, None if not available.\n\nThe emission value is a critical economic parameter, influencing the incentive distribution and\nreward mechanisms within the subnet.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnet_connection_requirements": {
    "name": "get_subnet_connection_requirements",
    "docstring": "Retrieves the connection requirements for a specific subnet within the Bittensor network. This\nfunction provides details on the criteria that must be met for neurons to connect to the subnet.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Dict[str, int]: A dictionary detailing the connection requirements for the subnet.\n\nUnderstanding these requirements is crucial for neurons looking to participate in or interact\nwith specific subnets, ensuring compliance with their connection standards.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Dict[str, int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnets": {
    "name": "get_subnets",
    "docstring": "Retrieves a list of all subnets currently active within the Bittensor network. This function\nprovides an overview of the various subnets and their identifiers.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    List[int]: A list of network UIDs representing each active subnet.\n\nThis function is valuable for understanding the network's structure and the diversity of subnets\navailable for neuron participation and collaboration.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_all_subnets_info": {
    "name": "get_all_subnets_info",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[SubnetInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_subnet_info": {
    "name": "get_subnet_info",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[SubnetInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_subnet_hyperparameters": {
    "name": "get_subnet_hyperparameters",
    "docstring": "Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters\ndefine the operational settings and rules governing the subnet's behavior.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Optional[SubnetHyperparameters]: The subnet's hyperparameters, or ``None`` if not available.\n\nUnderstanding the hyperparameters is crucial for comprehending how subnets are configured and\nmanaged, and how they interact with the network's consensus and incentive mechanisms.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Union[List, SubnetHyperparameters]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnet_owner": {
    "name": "get_subnet_owner",
    "docstring": "Retrieves the owner's address of a specific subnet within the Bittensor network. The owner is\ntypically the entity responsible for the creation and maintenance of the subnet.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Optional[str]: The SS58 address of the subnet's owner, or ``None`` if not available.\n\nKnowing the subnet owner provides insights into the governance and operational control of the subnet,\nwhich can be important for decision-making and collaboration within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "is_hotkey_delegate": {
    "name": "is_hotkey_delegate",
    "docstring": "Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function\nchecks if the neuron associated with the hotkey is part of the network's delegation system.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the neuron's hotkey.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    bool: ``True`` if the hotkey is a delegate, ``False`` otherwise.\n\nBeing a delegate is a significant status within the Bittensor network, indicating a neuron's\ninvolvement in consensus and governance processes.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_delegate_take": {
    "name": "get_delegate_take",
    "docstring": "Retrieves the delegate 'take' percentage for a neuron identified by its hotkey. The 'take'\nrepresents the percentage of rewards that the delegate claims from its nominators' stakes.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Optional[float]: The delegate take percentage, None if not available.\n\nThe delegate take is a critical parameter in the network's incentive structure, influencing\nthe distribution of rewards among neurons and their nominators.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[float]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_nominators_for_hotkey": {
    "name": "get_nominators_for_hotkey",
    "docstring": "Retrieves a list of nominators and their stakes for a neuron identified by its hotkey.\nNominators are neurons that stake their tokens on a delegate to support its operations.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n   Union[List[Tuple[str, Balance]], int]: A list of tuples containing each nominator's address and staked amount or 0.\n\nThis function provides insights into the neuron's support network within the Bittensor ecosystem,\nindicating its trust and collaboration relationships.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Union[List[Tuple[str, Balance]], int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_delegate_by_hotkey": {
    "name": "get_delegate_by_hotkey",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional['DelegateInfo']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_delegates_lite": {
    "name": "get_delegates_lite",
    "docstring": "Retrieves a lighter list of all delegate neurons within the Bittensor network. This function provides an\noverview of the neurons that are actively involved in the network's delegation system.\n\nAnalyzing the delegate population offers insights into the network's governance dynamics and the distribution\nof trust and responsibility among participating neurons.\n\nThis is a lighter version of :func:`get_delegates`.\n\nArgs:\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    List[DelegateInfoLite]: A list of ``DelegateInfoLite`` objects detailing each delegate's characteristics.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[DelegateInfoLite]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_delegates": {
    "name": "get_delegates",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List['DelegateInfo']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_delegated": {
    "name": "get_delegated",
    "docstring": "Returns the list of delegates that a given coldkey is staked to.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[Tuple['DelegateInfo', 'Balance']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_stake_info_for_coldkey": {
    "name": "get_stake_info_for_coldkey",
    "docstring": "Retrieves stake information associated with a specific coldkey. This function provides details\nabout the stakes held by an account, including the staked amounts and associated delegates.\n\nArgs:\n    coldkey_ss58 (str): The ``SS58`` address of the account's coldkey.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    List[StakeInfo]: A list of StakeInfo objects detailing the stake allocations for the account.\n\nStake information is vital for account holders to assess their investment and participation\nin the network's delegation and consensus processes.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[List[StakeInfo]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_stake_info_for_coldkeys": {
    "name": "get_stake_info_for_coldkeys",
    "docstring": "Retrieves stake information for a list of coldkeys. This function aggregates stake data for multiple\naccounts, providing a collective view of their stakes and delegations.\n\nArgs:\n    coldkey_ss58_list (List[str]): A list of ``SS58`` addresses of the accounts' coldkeys.\n    block (Optional[int], optional): The blockchain block number for the query.\n\nReturns:\n    Dict[str, List[StakeInfo]]: A dictionary mapping each coldkey to a list of its StakeInfo objects.\n\nThis function is useful for analyzing the stake distribution and delegation patterns of multiple\naccounts simultaneously, offering a broader perspective on network participation and investment strategies.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "coldkey_ss58_list",
        "type": "List[str]"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[Dict[str, List[StakeInfo]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_minimum_required_stake": {
    "name": "get_minimum_required_stake",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "is_hotkey_registered_any": {
    "name": "is_hotkey_registered_any",
    "docstring": "Checks if a neuron's hotkey is registered on any subnet within the Bittensor network.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int]): The blockchain block number at which to perform the check.\n\nReturns:\n    bool: ``True`` if the hotkey is registered on any subnet, False otherwise.\n\nThis function is essential for determining the network-wide presence and participation of a neuron.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "is_hotkey_registered_on_subnet": {
    "name": "is_hotkey_registered_on_subnet",
    "docstring": "Checks if a neuron's hotkey is registered on a specific subnet within the Bittensor network.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number at which to perform the check.\n\nReturns:\n    bool: ``True`` if the hotkey is registered on the specified subnet, False otherwise.\n\nThis function helps in assessing the participation of a neuron in a particular subnet,\nindicating its specific area of operation or influence within the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "is_hotkey_registered": {
    "name": "is_hotkey_registered",
    "docstring": "Determines whether a given hotkey (public key) is registered in the Bittensor network, either\nglobally across any subnet or specifically on a specified subnet. This function checks the registration\nstatus of a neuron identified by its hotkey, which is crucial for validating its participation and\nactivities within the network.\n\nArgs:\n    hotkey_ss58 (str): The SS58 address of the neuron's hotkey.\n    netuid (Optional[int]): The unique identifier of the subnet to check the registration. If ``None``, the\n        registration is checked across all subnets.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    bool: ``True`` if the hotkey is registered in the specified context (either any subnet or a specific\n        subnet), ``False`` otherwise.\n\nThis function is important for verifying the active status of neurons in the Bittensor network. It aids\nin understanding whether a neuron is eligible to participate in network processes such as consensus,\nvalidation, and incentive distribution based on its registration status.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "Optional[int]"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_uid_for_hotkey_on_subnet": {
    "name": "get_uid_for_hotkey_on_subnet",
    "docstring": "Retrieves the unique identifier (UID) for a neuron's hotkey on a specific subnet.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.\n\nThe UID is a critical identifier within the network, linking the neuron's hotkey to its\noperational and governance activities on a particular subnet.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_all_uids_for_hotkey": {
    "name": "get_all_uids_for_hotkey",
    "docstring": "Retrieves all unique identifiers (UIDs) associated with a given hotkey across different subnets\nwithin the Bittensor network. This function helps in identifying all the neuron instances that are\nlinked to a specific hotkey.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    List[int]: A list of UIDs associated with the given hotkey across various subnets.\n\nThis function is important for tracking a neuron's presence and activities across different\nsubnets within the Bittensor ecosystem.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_netuids_for_hotkey": {
    "name": "get_netuids_for_hotkey",
    "docstring": "Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function\nidentifies the specific subnets within the Bittensor network where the neuron associated with\nthe hotkey is active.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    List[int]: A list of netuids where the neuron is a member.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_neuron_for_pubkey_and_subnet": {
    "name": "get_neuron_for_pubkey_and_subnet",
    "docstring": "Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific\nsubnet UID (netuid). This function provides detailed neuron information for a particular subnet within\nthe Bittensor network.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    Optional[NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.\n\nThis function is crucial for accessing specific neuron data and understanding its status, stake,\nand other attributes within a particular subnet of the Bittensor ecosystem.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_all_neurons_for_pubkey": {
    "name": "get_all_neurons_for_pubkey",
    "docstring": "Retrieves information about all neuron instances associated with a given public key (hotkey ``SS58``\naddress) across different subnets of the Bittensor network. This function aggregates neuron data\nfrom various subnets to provide a comprehensive view of a neuron's presence and status within the network.\n\nArgs:\n    hotkey_ss58 (str): The ``SS58`` address of the neuron's hotkey.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    List[NeuronInfo]: A list of NeuronInfo objects detailing the neuron's presence across various subnets.\n\nThis function is valuable for analyzing a neuron's overall participation, influence, and\ncontributions across the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "neuron_has_validator_permit": {
    "name": "neuron_has_validator_permit",
    "docstring": "Checks if a neuron, identified by its unique identifier (UID), has a validator permit on a specific\nsubnet within the Bittensor network. This function determines whether the neuron is authorized to\nparticipate in validation processes on the subnet.\n\nArgs:\n    uid (int): The unique identifier of the neuron.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[bool]: ``True`` if the neuron has a validator permit, False otherwise.\n\nThis function is essential for understanding a neuron's role and capabilities within a specific\nsubnet, particularly regarding its involvement in network validation and governance.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[bool]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "neuron_for_wallet": {
    "name": "neuron_for_wallet",
    "docstring": "Retrieves information about a neuron associated with a given wallet on a specific subnet.\nThis function provides detailed data about the neuron's status, stake, and activities based on\nthe wallet's hotkey address.\n\nArgs:\n    wallet (bittensor.wallet): The wallet associated with the neuron.\n    netuid (int): The unique identifier of the subnet.\n    block (Optional[int]): The blockchain block number at which to perform the query.\n\nReturns:\n    Optional[NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.\n\nThis function is important for wallet owners to understand and manage their neuron's presence\nand activities within a particular subnet of the Bittensor network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "neuron_for_uid": {
    "name": "neuron_for_uid",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "neurons": {
    "name": "neurons",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "neuron_for_uid_lite": {
    "name": "neuron_for_uid_lite",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[NeuronInfoLite]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "neurons_lite": {
    "name": "neurons_lite",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[NeuronInfoLite]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "metagraph": {
    "name": "metagraph",
    "docstring": "Returns a synced metagraph for a specified subnet within the Bittensor network. The metagraph\nrepresents the network's structure, including neuron connections and interactions.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    lite (bool, default=True): If true, returns a metagraph using a lightweight sync (no weights, no bonds).\n    block (Optional[int]): Block number for synchronization, or ``None`` for the latest block.\n\nReturns:\n    bittensor.Metagraph: The metagraph representing the subnet's structure and neuron relationships.\n\nThe metagraph is an essential tool for understanding the topology and dynamics of the Bittensor\nnetwork's decentralized architecture, particularly in relation to neuron interconnectivity and consensus\n    processes.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "lite",
        "type": "bool"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "'bittensor.metagraph'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "incentive": {
    "name": "incentive",
    "docstring": "Retrieves the list of incentives for neurons within a specific subnet of the Bittensor network.\nThis function provides insights into the reward distribution mechanisms and the incentives allocated\nto each neuron based on their contributions and activities.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    List[int]: The list of incentives for neurons within the subnet, indexed by UID.\n\nUnderstanding the incentive structure is crucial for analyzing the network's economic model and\nthe motivational drivers for neuron participation and collaboration.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "weights": {
    "name": "weights",
    "docstring": "Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network.\nThis function maps each neuron's UID to the weights it assigns to other neurons, reflecting the\nnetwork's trust and value assignment mechanisms.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    List[Tuple[int, List[Tuple[int, int]]]]: A list of tuples mapping each neuron's UID to its assigned weights.\n\nThe weight distribution is a key factor in the network's consensus algorithm and the ranking of neurons,\ninfluencing their influence and reward allocation within the subnet.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[Tuple[int, List[Tuple[int, int]]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "bonds": {
    "name": "bonds",
    "docstring": "Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network.\nBonds represent the investments or commitments made by neurons in one another, indicating a level\nof trust and perceived value. This bonding mechanism is integral to the network's market-based approach\nto measuring and rewarding machine intelligence.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    List[Tuple[int, List[Tuple[int, int]]]]: A list of tuples mapping each neuron's UID to its bonds with other\n        neurons.\n\nUnderstanding bond distributions is crucial for analyzing the trust dynamics and market behavior\nwithin the subnet. It reflects how neurons recognize and invest in each other's intelligence and\ncontributions, supporting diverse and niche systems within the Bittensor ecosystem.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "List[Tuple[int, List[Tuple[int, int]]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "associated_validator_ip_info": {
    "name": "associated_validator_ip_info",
    "docstring": "Retrieves the list of all validator IP addresses associated with a specific subnet in the Bittensor\nnetwork. This information is crucial for network communication and the identification of validator nodes.\n\nArgs:\n    netuid (int): The network UID of the subnet to query.\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    Optional[List[IPInfo]]: A list of IPInfo objects for validator nodes in the subnet, or ``None`` if no\n        validators are associated.\n\nValidator IP information is key for establishing secure and reliable connections within the network,\nfacilitating consensus and validation processes critical for the network's integrity and performance.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[List['IPInfo']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_subnet_burn_cost": {
    "name": "get_subnet_burn_cost",
    "docstring": "Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost\nrepresents the amount of Tao that needs to be locked or burned to establish a new subnet.\n\nArgs:\n    block (Optional[int]): The blockchain block number for the query.\n\nReturns:\n    int: The burn cost for subnet registration.\n\nThe subnet burn cost is an important economic parameter, reflecting the network's mechanisms for\ncontrolling the proliferation of subnets and ensuring their commitment to the network's long-term viability.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_delegation": {
    "name": "_do_delegation",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_undelegation": {
    "name": "_do_undelegation",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_nominate": {
    "name": "_do_nominate",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_do_increase_take": {
    "name": "_do_increase_take",
    "docstring": "Increases the take rate for a delegate's hotkey.\n\nThis method sends a transaction to increase the take rate for a delegate's hotkey and retries the call up to\nthree times with exponential backoff in case of failures.\n\nArgs:\n    wallet (bittensor.wallet): The wallet from which the transaction will be signed.\n    hotkey_ss58 (str): The SS58 address of the delegate's hotkey.\n    take (int): The new take rate to be set.\n    wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.\n    wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.\n\nReturns:\n    bool: ``True`` if the take rate increase is successful, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "take",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "_do_decrease_take": {
    "name": "_do_decrease_take",
    "docstring": "Decreases the take rate for a delegate's hotkey.\n\nThis method sends a transaction to decrease the take rate for a delegate's hotkey and retries the call up to\nthree times with exponential backoff in case of failures.\n\nArgs:\n    wallet (bittensor.wallet): The wallet from which the transaction will be signed.\n    hotkey_ss58 (str): The SS58 address of the delegate's hotkey.\n    take (int): The new take rate to be set.\n    wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.\n    wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.\n\nReturns:\n    bool: ``True`` if the take rate decrease is successful, ``False`` otherwise.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "take",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_balance": {
    "name": "get_balance",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "address",
        "type": "str"
      },
      {
        "name": "block",
        "type": "int"
      }
    ],
    "returns": "'Balance'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_current_block": {
    "name": "get_current_block",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_balances": {
    "name": "get_balances",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block",
        "type": "int"
      }
    ],
    "returns": "Dict[str, 'Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_null_neuron": {
    "name": "_null_neuron",
    "docstring": null,
    "parameters": [],
    "returns": "NeuronInfo",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "get_block_hash": {
    "name": "get_block_hash",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "block_id",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_error_info_by_index": {
    "name": "get_error_info_by_index",
    "docstring": "Returns the error name and description from the Subtensor error list.\n\nArgs:\n    error_index (int): The index of the error to retrieve.\n\nReturns:\n    Tuple[str, str]: A tuple containing the error name and description from substrate metadata. If the error index is not found, returns (\"Unknown Error\", \"\") and logs a warning.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "error_index",
        "type": "int"
      }
    ],
    "returns": "Tuple[str, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subtensor.py"
  },
  "make_substrate_call_with_retry": {
    "name": "make_substrate_call_with_retry",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/serving.py"
  },
  "prepare_synapse": {
    "name": "prepare_synapse",
    "docstring": "Prepare the synapse-specific payload.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Any",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subnets.py"
  },
  "process_responses": {
    "name": "process_responses",
    "docstring": "Process the responses from the network.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "responses",
        "type": "List[Union['bt.Synapse', Any]]"
      }
    ],
    "returns": "Any",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/subnets.py"
  },
  "error": {
    "name": "error",
    "docstring": "Wraps error message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "__create_parser__": {
    "name": "__create_parser__",
    "docstring": "Creates the argument parser for the Bittensor CLI.\n\nReturns:\n    argparse.ArgumentParser: An argument parser object for Bittensor CLI.",
    "parameters": [],
    "returns": "'argparse.ArgumentParser'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/cli.py"
  },
  "create_config": {
    "name": "create_config",
    "docstring": "From the argument parser, add config to bittensor.executor and local config\n\nArgs:\n    args (List[str]): List of command line arguments.\n\nReturns:\n    bittensor.config: The configuration object for Bittensor CLI.",
    "parameters": [
      {
        "name": "args",
        "type": "List[str]"
      }
    ],
    "returns": "'bittensor.config'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/cli.py"
  },
  "extract_response_json": {
    "name": "extract_response_json",
    "docstring": "Abstract method that must be implemented by the subclass.\nThis method should provide logic to extract JSON data from the response, including headers and content.\nIt is called after the response has been processed and is responsible for retrieving structured data\nthat can be used by the application.\n\nArgs:\n    response: The response object from which to extract JSON data.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "response",
        "type": "ClientResponse"
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/stream.py"
  },
  "create_streaming_response": {
    "name": "create_streaming_response",
    "docstring": "Creates a streaming response using the provided token streamer.\nThis method can be used by the subclass to create a response object that can be sent back to the client.\nThe token streamer should be implemented to generate the content of the response according to the specific\nrequirements of the subclass.\n\nArgs:\n    token_streamer: A callable that takes a send function and returns an awaitable. It's responsible for generating the content of the response.\n\nReturns:\n    BTStreamingResponse: The streaming response object, ready to be sent to the client.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "token_streamer",
        "type": "Callable[[Send], Awaitable[None]]"
      }
    ],
    "returns": "BTStreamingResponse",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/stream.py"
  },
  "cast_dtype": {
    "name": "cast_dtype",
    "docstring": "Casts the raw value to a string representing the\n`numpy data type <https://numpy.org/doc/stable/user/basics.types.html>`_, or the\n`torch data type <https://pytorch.org/docs/stable/tensor_attributes.html>`_ if using torch.\n\nArgs:\n    raw (Union[None, numpy.dtype, torch.dtype, str]): The raw value to cast.\n\nReturns:\n    str: The string representing the numpy/torch data type.\n\nRaises:\n    Exception: If the raw value is of an invalid type.",
    "parameters": [
      {
        "name": "raw",
        "type": "Union[None, np.dtype, 'torch.dtype', str]"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "cast_shape": {
    "name": "cast_shape",
    "docstring": "Casts the raw value to a string representing the tensor shape.\n\nArgs:\n    raw (Union[None, List[int], str]): The raw value to cast.\n\nReturns:\n    str: The string representing the tensor shape.\n\nRaises:\n    Exception: If the raw value is of an invalid type or if the list elements are not of type int.",
    "parameters": [
      {
        "name": "raw",
        "type": "Union[None, List[int], str]"
      }
    ],
    "returns": "Optional[Union[str, list]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "__getitem__": {
    "name": "__getitem__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "key",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "__contains__": {
    "name": "__contains__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "key",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "_add_torch": {
    "name": "_add_torch",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "__new__": {
    "name": "__new__",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "tensor",
        "type": "Union[list, np.ndarray, 'torch.Tensor']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "tensor": {
    "name": "tensor",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "Union[np.ndarray, 'torch.Tensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "tolist": {
    "name": "tolist",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "List[object]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "numpy": {
    "name": "numpy",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "'numpy.ndarray'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "serialize": {
    "name": "serialize",
    "docstring": "Serializes the given tensor.\n\nArgs:\n    tensor_ (np.array or torch.Tensor): The tensor to serialize.\n\nReturns:\n    Tensor: The serialized tensor.\n\nRaises:\n    Exception: If the serialization process encounters an error.",
    "parameters": [
      {
        "name": "tensor_",
        "type": "Union['np.ndarray', 'torch.Tensor']"
      }
    ],
    "returns": "'Tensor'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/tensor.py"
  },
  "ss58_to_vec_u8": {
    "name": "ss58_to_vec_u8",
    "docstring": null,
    "parameters": [
      {
        "name": "ss58_address",
        "type": "str"
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "_unbiased_topk": {
    "name": "_unbiased_topk",
    "docstring": "Selects topk as in torch.topk but does not bias lower indices when values are equal.\nArgs:\n    values: (np.ndarray) if using numpy, (torch.Tensor) if using torch:\n        Values to index into.\n    k: (int):\n        Number to take.\n    dim: (int):\n        Dimension to index into (used by Torch)\n    sorted: (bool):\n        Whether to sort indices.\n    largest: (bool):\n        Whether to take the largest value.\n    axis: (int):\n        Axis along which to index into (used by Numpy)\n    return_type: (str):\n        Whether or use torch or numpy approach\n\nReturn:\n    topk: (np.ndarray) if using numpy, (torch.Tensor) if using torch:\n        topk k values.\n    indices: (np.ndarray) if using numpy, (torch.LongTensor) if using torch:\n        indices of the topk values.",
    "parameters": [
      {
        "name": "values",
        "type": "Union[np.ndarray, 'torch.Tensor']"
      },
      {
        "name": "k",
        "type": "int"
      },
      {
        "name": "dim",
        "type": null
      },
      {
        "name": "sorted",
        "type": null
      },
      {
        "name": "largest",
        "type": null
      },
      {
        "name": "axis",
        "type": null
      },
      {
        "name": "return_type",
        "type": "str"
      }
    ],
    "returns": "Union[Tuple[np.ndarray, np.ndarray], Tuple['torch.Tensor', 'torch.LongTensor']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "unbiased_topk": {
    "name": "unbiased_topk",
    "docstring": "Selects topk as in torch.topk but does not bias lower indices when values are equal.\nArgs:\n    values: (np.ndarray) if using numpy, (torch.Tensor) if using torch:\n        Values to index into.\n    k: (int):\n        Number to take.\n    dim: (int):\n        Dimension to index into (used by Torch)\n    sorted: (bool):\n        Whether to sort indices.\n    largest: (bool):\n        Whether to take the largest value.\n    axis: (int):\n        Axis along which to index into (used by Numpy)\n\nReturn:\n    topk: (np.ndarray) if using numpy, (torch.Tensor) if using torch:\n        topk k values.\n    indices: (np.ndarray) if using numpy, (torch.LongTensor) if using torch:\n        indices of the topk values.",
    "parameters": [
      {
        "name": "values",
        "type": "Union[np.ndarray, 'torch.Tensor']"
      },
      {
        "name": "k",
        "type": "int"
      },
      {
        "name": "dim",
        "type": "int"
      },
      {
        "name": "sorted",
        "type": "bool"
      },
      {
        "name": "largest",
        "type": "bool"
      },
      {
        "name": "axis",
        "type": "int"
      }
    ],
    "returns": "Union[Tuple[np.ndarray, np.ndarray], Tuple['torch.Tensor', 'torch.LongTensor']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "strtobool_with_default": {
    "name": "strtobool_with_default",
    "docstring": "Creates a strtobool function with a default value.\n\nArgs:\n    default(bool): The default value to return if the string is empty.\n\nReturns:\n    The strtobool function with the default value.",
    "parameters": [
      {
        "name": "default",
        "type": "bool"
      }
    ],
    "returns": "Callable[[str], Union[bool, Literal['==SUPRESS==']]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "strtobool": {
    "name": "strtobool",
    "docstring": "Converts a string to a boolean value.\n\ntruth-y values are 'y', 'yes', 't', 'true', 'on', and '1';\nfalse-y values are 'n', 'no', 'f', 'false', 'off', and '0'.\n\nRaises ValueError if 'val' is anything else.",
    "parameters": [
      {
        "name": "val",
        "type": "str"
      }
    ],
    "returns": "Union[bool, Literal['==SUPRESS==']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "get_explorer_root_url_by_network_from_map": {
    "name": "get_explorer_root_url_by_network_from_map",
    "docstring": "Returns the explorer root url for the given network name from the given network map.\n\nArgs:\n    network(str): The network to get the explorer url for.\n    network_map(Dict[str, str]): The network map to get the explorer url from.\n\nReturns:\n    The explorer url for the given network.\n    Or None if the network is not in the network map.",
    "parameters": [
      {
        "name": "network",
        "type": "str"
      },
      {
        "name": "network_map",
        "type": "Dict[str, Dict[str, str]]"
      }
    ],
    "returns": "Optional[Dict[str, str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "get_explorer_url_for_network": {
    "name": "get_explorer_url_for_network",
    "docstring": "Returns the explorer url for the given block hash and network.\n\nArgs:\n    network(str): The network to get the explorer url for.\n    block_hash(str): The block hash to get the explorer url for.\n    network_map(Dict[str, Dict[str, str]]): The network maps to get the explorer urls from.\n\nReturns:\n    The explorer url for the given block hash and network.\n    Or None if the network is not known.",
    "parameters": [
      {
        "name": "network",
        "type": "str"
      },
      {
        "name": "block_hash",
        "type": "str"
      },
      {
        "name": "network_map",
        "type": "Dict[str, str]"
      }
    ],
    "returns": "Optional[List[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "ss58_address_to_bytes": {
    "name": "ss58_address_to_bytes",
    "docstring": "Converts a ss58 address to a bytes object.",
    "parameters": [
      {
        "name": "ss58_address",
        "type": "str"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "U16_NORMALIZED_FLOAT": {
    "name": "U16_NORMALIZED_FLOAT",
    "docstring": null,
    "parameters": [
      {
        "name": "x",
        "type": "int"
      }
    ],
    "returns": "float",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "U64_NORMALIZED_FLOAT": {
    "name": "U64_NORMALIZED_FLOAT",
    "docstring": null,
    "parameters": [
      {
        "name": "x",
        "type": "int"
      }
    ],
    "returns": "float",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "u8_key_to_ss58": {
    "name": "u8_key_to_ss58",
    "docstring": "Converts a u8-encoded account key to an ss58 address.\n\nArgs:\n    u8_key (List[int]): The u8-encoded account key.",
    "parameters": [
      {
        "name": "u8_key",
        "type": "List[int]"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "hash": {
    "name": "hash",
    "docstring": null,
    "parameters": [
      {
        "name": "content",
        "type": null
      },
      {
        "name": "encoding",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "format_error_message": {
    "name": "format_error_message",
    "docstring": "Formats an error message from the Subtensor error information to using in extrinsics.\n\nArgs:\n    error_message (dict): A dictionary containing the error information from Subtensor.\n\nReturns:\n    str: A formatted error message string.",
    "parameters": [
      {
        "name": "error_message",
        "type": "dict"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/__init__.py"
  },
  "get_human_readable": {
    "name": "get_human_readable",
    "docstring": null,
    "parameters": [
      {
        "name": "num",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/formatting.py"
  },
  "millify": {
    "name": "millify",
    "docstring": null,
    "parameters": [
      {
        "name": "n",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/formatting.py"
  },
  "convert_blocks_to_time": {
    "name": "convert_blocks_to_time",
    "docstring": "Converts number of blocks into number of hours, minutes, seconds.\n:param blocks: number of blocks\n:param block_time: time per block, by default this is 12\n:return: tuple containing number of hours, number of minutes, number of seconds",
    "parameters": [
      {
        "name": "blocks",
        "type": "int"
      },
      {
        "name": "block_time",
        "type": "int"
      }
    ],
    "returns": "tuple[int, int, int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/formatting.py"
  },
  "tao": {
    "name": "tao",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__int__": {
    "name": "__int__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__float__": {
    "name": "__float__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "float",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rich__": {
    "name": "__rich__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__str_rao__": {
    "name": "__str_rao__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rich_rao__": {
    "name": "__rich_rao__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__ne__": {
    "name": "__ne__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__gt__": {
    "name": "__gt__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__lt__": {
    "name": "__lt__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__le__": {
    "name": "__le__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__ge__": {
    "name": "__ge__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__add__": {
    "name": "__add__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__radd__": {
    "name": "__radd__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__sub__": {
    "name": "__sub__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rsub__": {
    "name": "__rsub__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__mul__": {
    "name": "__mul__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rmul__": {
    "name": "__rmul__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__truediv__": {
    "name": "__truediv__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rtruediv__": {
    "name": "__rtruediv__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__floordiv__": {
    "name": "__floordiv__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__rfloordiv__": {
    "name": "__rfloordiv__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "other",
        "type": "Union[int, float, 'Balance']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__nonzero__": {
    "name": "__nonzero__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__neg__": {
    "name": "__neg__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__pos__": {
    "name": "__pos__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "__abs__": {
    "name": "__abs__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "from_float": {
    "name": "from_float",
    "docstring": "Given tao (float), return Balance object with rao(int) and tao(float), where rao = int(tao*pow(10,9))\nArgs:\n    amount: The amount in tao.\n\nReturns:\n    A Balance object representing the given amount.",
    "parameters": [
      {
        "name": "amount",
        "type": "float"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "from_tao": {
    "name": "from_tao",
    "docstring": "Given tao (float), return Balance object with rao(int) and tao(float), where rao = int(tao*pow(10,9))\n\nArgs:\n    amount: The amount in tao.\n\nReturns:\n    A Balance object representing the given amount.",
    "parameters": [
      {
        "name": "amount",
        "type": "float"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "from_rao": {
    "name": "from_rao",
    "docstring": "Given rao (int), return Balance object with rao(int) and tao(float), where rao = int(tao*pow(10,9))\n\nArgs:\n    amount: The amount in rao.\n\nReturns:\n    A Balance object representing the given amount.",
    "parameters": [
      {
        "name": "amount",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/balance.py"
  },
  "get_ss58_format": {
    "name": "get_ss58_format",
    "docstring": "Returns the ss58 format of the given ss58 address.",
    "parameters": [
      {
        "name": "ss58_address",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "is_valid_ss58_address": {
    "name": "is_valid_ss58_address",
    "docstring": "Checks if the given address is a valid ss58 address.\n\nArgs:\n    address(str): The address to check.\n\nReturns:\n    True if the address is a valid ss58 address for Bittensor, False otherwise.",
    "parameters": [
      {
        "name": "address",
        "type": "str"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "is_valid_ed25519_pubkey": {
    "name": "is_valid_ed25519_pubkey",
    "docstring": "Checks if the given public_key is a valid ed25519 key.\n\nArgs:\n    public_key(Union[str, bytes]): The public_key to check.\n\nReturns:\n    True if the public_key is a valid ed25519 key, False otherwise.",
    "parameters": [
      {
        "name": "public_key",
        "type": "Union[str, bytes]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "is_valid_bittensor_address_or_public_key": {
    "name": "is_valid_bittensor_address_or_public_key",
    "docstring": "Checks if the given address is a valid destination address.\n\nArgs:\n    address(Union[str, bytes]): The address to check.\n\nReturns:\n    True if the address is a valid destination address, False otherwise.",
    "parameters": [
      {
        "name": "address",
        "type": "Union[str, bytes]"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "create_identity_dict": {
    "name": "create_identity_dict",
    "docstring": "Creates a dictionary with structure for identity extrinsic. Must fit within 64 bits.\n\nArgs:\n    display (str): String to be converted and stored under 'display'.\n    legal (str): String to be converted and stored under 'legal'.\n    web (str): String to be converted and stored under 'web'.\n    riot (str): String to be converted and stored under 'riot'.\n    email (str): String to be converted and stored under 'email'.\n    pgp_fingerprint (str): String to be converted and stored under 'pgp_fingerprint'.\n    image (str): String to be converted and stored under 'image'.\n    info (str): String to be converted and stored under 'info'.\n    twitter (str): String to be converted and stored under 'twitter'.\n\nReturns:\n    dict: A dictionary with the specified structure and byte string conversions.\n\nRaises:\nValueError: If pgp_fingerprint is not exactly 20 bytes long when encoded.",
    "parameters": [
      {
        "name": "display",
        "type": "str"
      },
      {
        "name": "legal",
        "type": "str"
      },
      {
        "name": "web",
        "type": "str"
      },
      {
        "name": "riot",
        "type": "str"
      },
      {
        "name": "email",
        "type": "str"
      },
      {
        "name": "pgp_fingerprint",
        "type": "Optional[str]"
      },
      {
        "name": "image",
        "type": "str"
      },
      {
        "name": "info",
        "type": "str"
      },
      {
        "name": "twitter",
        "type": "str"
      }
    ],
    "returns": "dict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "decode_hex_identity_dict": {
    "name": "decode_hex_identity_dict",
    "docstring": null,
    "parameters": [
      {
        "name": "info_dictionary",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/wallet_utils.py"
  },
  "use_torch": {
    "name": "use_torch",
    "docstring": "Force the use of torch over numpy for certain operations.",
    "parameters": [],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "legacy_torch_api_compat": {
    "name": "legacy_torch_api_compat",
    "docstring": "Convert function operating on numpy Input&Output to legacy torch Input&Output API if `use_torch()` is True.\n\nArgs:\n    func (function):\n        Function with numpy Input/Output to be decorated.\nReturns:\n    decorated (function):\n        Decorated function.",
    "parameters": [
      {
        "name": "func",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_get_real_torch": {
    "name": "_get_real_torch",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "log_no_torch_error": {
    "name": "log_no_torch_error",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_hex_bytes_to_u8_list": {
    "name": "_hex_bytes_to_u8_list",
    "docstring": null,
    "parameters": [
      {
        "name": "hex_bytes",
        "type": "bytes"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "_create_seal_hash": {
    "name": "_create_seal_hash",
    "docstring": null,
    "parameters": [
      {
        "name": "block_and_hotkey_hash_hex",
        "type": "bytes"
      },
      {
        "name": "nonce",
        "type": "int"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "_seal_meets_difficulty": {
    "name": "_seal_meets_difficulty",
    "docstring": null,
    "parameters": [
      {
        "name": "seal",
        "type": "bytes"
      },
      {
        "name": "difficulty",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "_solve_for_nonce_block_cuda": {
    "name": "_solve_for_nonce_block_cuda",
    "docstring": "Tries to solve the POW on a CUDA device for a block of nonces (nonce_start, nonce_start + update_interval * tpb",
    "parameters": [
      {
        "name": "nonce_start",
        "type": "int"
      },
      {
        "name": "update_interval",
        "type": "int"
      },
      {
        "name": "block_and_hotkey_hash_bytes",
        "type": "bytes"
      },
      {
        "name": "difficulty",
        "type": "int"
      },
      {
        "name": "limit",
        "type": "int"
      },
      {
        "name": "block_number",
        "type": "int"
      },
      {
        "name": "dev_id",
        "type": "int"
      },
      {
        "name": "tpb",
        "type": "int"
      }
    ],
    "returns": "Optional[POWSolution]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_solve_for_nonce_block": {
    "name": "_solve_for_nonce_block",
    "docstring": "Tries to solve the POW for a block of nonces (nonce_start, nonce_end)",
    "parameters": [
      {
        "name": "nonce_start",
        "type": "int"
      },
      {
        "name": "nonce_end",
        "type": "int"
      },
      {
        "name": "block_and_hotkey_hash_bytes",
        "type": "bytes"
      },
      {
        "name": "difficulty",
        "type": "int"
      },
      {
        "name": "limit",
        "type": "int"
      },
      {
        "name": "block_number",
        "type": "int"
      }
    ],
    "returns": "Optional[POWSolution]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_registration_diff_unpack": {
    "name": "_registration_diff_unpack",
    "docstring": "Unpacks the packed two 32-bit integers into one 64-bit integer. Little endian.",
    "parameters": [
      {
        "name": "packed_diff",
        "type": "multiprocessing.Array"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_registration_diff_pack": {
    "name": "_registration_diff_pack",
    "docstring": "Packs the difficulty into two 32-bit integers. Little endian.",
    "parameters": [
      {
        "name": "diff",
        "type": "int"
      },
      {
        "name": "packed_diff",
        "type": "multiprocessing.Array"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_hash_block_with_hotkey": {
    "name": "_hash_block_with_hotkey",
    "docstring": "Hashes the block with the hotkey using Keccak-256 to get 32 bytes",
    "parameters": [
      {
        "name": "block_bytes",
        "type": "bytes"
      },
      {
        "name": "hotkey_bytes",
        "type": "bytes"
      }
    ],
    "returns": "bytes",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_update_curr_block": {
    "name": "_update_curr_block",
    "docstring": null,
    "parameters": [
      {
        "name": "curr_diff",
        "type": "multiprocessing.Array"
      },
      {
        "name": "curr_block",
        "type": "multiprocessing.Array"
      },
      {
        "name": "curr_block_num",
        "type": "multiprocessing.Value"
      },
      {
        "name": "block_number",
        "type": "int"
      },
      {
        "name": "block_bytes",
        "type": "bytes"
      },
      {
        "name": "diff",
        "type": "int"
      },
      {
        "name": "hotkey_bytes",
        "type": "bytes"
      },
      {
        "name": "lock",
        "type": "multiprocessing.Lock"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "get_cpu_count": {
    "name": "get_cpu_count",
    "docstring": null,
    "parameters": [],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_solve_for_difficulty_fast": {
    "name": "_solve_for_difficulty_fast",
    "docstring": "Solves the POW for registration using multiprocessing.\nArgs:\n    subtensor\n        Subtensor to connect to for block information and to submit.\n    wallet:\n        wallet to use for registration.\n    netuid: int\n        The netuid of the subnet to register to.\n    output_in_place: bool\n        If true, prints the status in place. Otherwise, prints the status on a new line.\n    num_processes: int\n        Number of processes to use.\n    update_interval: int\n        Number of nonces to solve before updating block information.\n    n_samples: int\n        The number of samples of the hash_rate to keep for the EWMA\n    alpha_: float\n        The alpha for the EWMA for the hash_rate calculation\n    log_verbose: bool\n        If true, prints more verbose logging of the registration metrics.\nNote: The hash rate is calculated as an exponentially weighted moving average in order to make the measure more robust.\nNote:\n- We can also modify the update interval to do smaller blocks of work,\n    while still updating the block information after a different number of nonces,\n    to increase the transparency of the process while still keeping the speed.",
    "parameters": [
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "num_processes",
        "type": "Optional[int]"
      },
      {
        "name": "update_interval",
        "type": "Optional[int]"
      },
      {
        "name": "n_samples",
        "type": "int"
      },
      {
        "name": "alpha_",
        "type": "float"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "Optional[POWSolution]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_get_block_with_retry": {
    "name": "_get_block_with_retry",
    "docstring": "Gets the current block number, difficulty, and block hash from the substrate node.\n\nArgs:\n    subtensor (:obj:`bittensor.subtensor`, `required`):\n        The subtensor object to use to get the block number, difficulty, and block hash.\n\n    netuid (:obj:`int`, `required`):\n        The netuid of the network to get the block number, difficulty, and block hash from.\n\nReturns:\n    block_number (:obj:`int`):\n        The current block number.\n\n    difficulty (:obj:`int`):\n        The current difficulty of the subnet.\n\n    block_hash (:obj:`bytes`):\n        The current block hash.\n\nRaises:\n    Exception: If the block hash is None.\n    ValueError: If the difficulty is None.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "netuid",
        "type": "int"
      }
    ],
    "returns": "Tuple[int, int, bytes]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_check_for_newest_block_and_update": {
    "name": "_check_for_newest_block_and_update",
    "docstring": "Checks for a new block and updates the current block information if a new block is found.\n\nArgs:\n    subtensor (:obj:`bittensor.subtensor`, `required`):\n        The subtensor object to use for getting the current block.\n    netuid (:obj:`int`, `required`):\n        The netuid to use for retrieving the difficulty.\n    old_block_number (:obj:`int`, `required`):\n        The old block number to check against.\n    hotkey_bytes (:obj:`bytes`, `required`):\n        The bytes of the hotkey's pubkey.\n    curr_diff (:obj:`multiprocessing.Array`, `required`):\n        The current difficulty as a multiprocessing array.\n    curr_block (:obj:`multiprocessing.Array`, `required`):\n        Where the current block is stored as a multiprocessing array.\n    curr_block_num (:obj:`multiprocessing.Value`, `required`):\n        Where the current block number is stored as a multiprocessing value.\n    update_curr_block (:obj:`Callable`, `required`):\n        A function that updates the current block.\n    check_block (:obj:`multiprocessing.Lock`, `required`):\n        A mp lock that is used to check for a new block.\n    solvers (:obj:`List[_Solver]`, `required`):\n        A list of solvers to update the current block for.\n    curr_stats (:obj:`RegistrationStatistics`, `required`):\n        The current registration statistics to update.\n\nReturns:\n    (int) The current block number.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "old_block_number",
        "type": "int"
      },
      {
        "name": "hotkey_bytes",
        "type": "bytes"
      },
      {
        "name": "curr_diff",
        "type": "multiprocessing.Array"
      },
      {
        "name": "curr_block",
        "type": "multiprocessing.Array"
      },
      {
        "name": "curr_block_num",
        "type": "multiprocessing.Value"
      },
      {
        "name": "update_curr_block",
        "type": "Callable"
      },
      {
        "name": "check_block",
        "type": "'multiprocessing.Lock'"
      },
      {
        "name": "solvers",
        "type": "List[_Solver]"
      },
      {
        "name": "curr_stats",
        "type": "RegistrationStatistics"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_solve_for_difficulty_fast_cuda": {
    "name": "_solve_for_difficulty_fast_cuda",
    "docstring": "Solves the registration fast using CUDA\nArgs:\n    subtensor: bittensor.subtensor\n        The subtensor node to grab blocks\n    wallet: bittensor.wallet\n        The wallet to register\n    netuid: int\n        The netuid of the subnet to register to.\n    output_in_place: bool\n        If true, prints the output in place, otherwise prints to new lines\n    update_interval: int\n        The number of nonces to try before checking for more blocks\n    tpb: int\n        The number of threads per block. CUDA param that should match the GPU capability\n    dev_id: Union[List[int], int]\n        The CUDA device IDs to execute the registration on, either a single device or a list of devices\n    n_samples: int\n        The number of samples of the hash_rate to keep for the EWMA\n    alpha_: float\n        The alpha for the EWMA for the hash_rate calculation\n    log_verbose: bool\n        If true, prints more verbose logging of the registration metrics.\nNote: The hash rate is calculated as an exponentially weighted moving average in order to make the measure more robust.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "update_interval",
        "type": "int"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "n_samples",
        "type": "int"
      },
      {
        "name": "alpha_",
        "type": "float"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "Optional[POWSolution]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "_terminate_workers_and_wait_for_exit": {
    "name": "_terminate_workers_and_wait_for_exit",
    "docstring": null,
    "parameters": [
      {
        "name": "workers",
        "type": "List[multiprocessing.Process]"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "create_pow": {
    "name": "create_pow",
    "docstring": "Creates a proof of work for the given subtensor and wallet.\nArgs:\n    subtensor (:obj:`bittensor.subtensor.subtensor`, `required`):\n        The subtensor to create a proof of work for.\n    wallet (:obj:`bittensor.wallet.wallet`, `required`):\n        The wallet to create a proof of work for.\n    netuid (:obj:`int`, `required`):\n        The netuid for the subnet to create a proof of work for.\n    output_in_place (:obj:`bool`, `optional`, defaults to :obj:`True`):\n        If true, prints the progress of the proof of work to the console\n            in-place. Meaning the progress is printed on the same lines.\n    cuda (:obj:`bool`, `optional`, defaults to :obj:`False`):\n        If true, uses CUDA to solve the proof of work.\n    dev_id (:obj:`Union[List[int], int]`, `optional`, defaults to :obj:`0`):\n        The CUDA device id(s) to use. If cuda is true and dev_id is a list,\n            then multiple CUDA devices will be used to solve the proof of work.\n    tpb (:obj:`int`, `optional`, defaults to :obj:`256`):\n        The number of threads per block to use when solving the proof of work.\n        Should be a multiple of 32.\n    num_processes (:obj:`int`, `optional`, defaults to :obj:`None`):\n        The number of processes to use when solving the proof of work.\n        If None, then the number of processes is equal to the number of\n            CPU cores.\n    update_interval (:obj:`int`, `optional`, defaults to :obj:`None`):\n        The number of nonces to run before checking for a new block.\n    log_verbose (:obj:`bool`, `optional`, defaults to :obj:`False`):\n        If true, prints the progress of the proof of work more verbosely.\nReturns:\n    :obj:`Optional[Dict[str, Any]]`: The proof of work solution or None if\n        the wallet is already registered or there is a different error.\n\nRaises:\n    :obj:`ValueError`: If the subnet does not exist.",
    "parameters": [
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "wallet",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "cuda",
        "type": "bool"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "num_processes",
        "type": "int"
      },
      {
        "name": "update_interval",
        "type": "int"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "Optional[Dict[str, Any]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "decorated": {
    "name": "decorated",
    "docstring": null,
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "__bool__": {
    "name": "__bool__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "is_stale": {
    "name": "is_stale",
    "docstring": "Returns True if the POW is stale.\nThis means the block the POW is solved for is within 3 blocks of the current block.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "create_shared_memory": {
    "name": "create_shared_memory",
    "docstring": "Creates shared memory for the solver processes to use.",
    "parameters": [],
    "returns": "Tuple[multiprocessing.Array, multiprocessing.Value, multiprocessing.Array]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "get_status_message": {
    "name": "get_status_message",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "stats",
        "type": "RegistrationStatistics"
      },
      {
        "name": "verbose",
        "type": "bool"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "update": {
    "name": "update",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "stats",
        "type": "RegistrationStatistics"
      },
      {
        "name": "verbose",
        "type": "bool"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "__enter__": {
    "name": "__enter__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "__exit__": {
    "name": "__exit__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/registration.py"
  },
  "get_random_unused_port": {
    "name": "get_random_unused_port",
    "docstring": null,
    "parameters": [
      {
        "name": "allocated_ports",
        "type": "Set"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/test_utils.py"
  },
  "port_in_use": {
    "name": "port_in_use",
    "docstring": null,
    "parameters": [
      {
        "name": "port",
        "type": "int"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/test_utils.py"
  },
  "int_to_ip": {
    "name": "int_to_ip",
    "docstring": "Maps an integer to a unique ip-string\nArgs:\n    int_val  (:type:`int128`, `required`):\n        The integer representation of an ip. Must be in the range (0, 3.4028237e+38).\n\nReturns:\n    str_val (:tyep:`str`, `required):\n        The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n\nRaises:\n    netaddr.core.AddrFormatError (Exception):\n        Raised when the passed int_vals is not a valid ip int value.",
    "parameters": [
      {
        "name": "int_val",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "ip_to_int": {
    "name": "ip_to_int",
    "docstring": "Maps an ip-string to a unique integer.\narg:\n    str_val (:tyep:`str`, `required):\n        The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n\nReturns:\n    int_val  (:type:`int128`, `required`):\n        The integer representation of an ip. Must be in the range (0, 3.4028237e+38).\n\nRaises:\n    netaddr.core.AddrFormatError (Exception):\n        Raised when the passed str_val is not a valid ip string value.",
    "parameters": [
      {
        "name": "str_val",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "ip_version": {
    "name": "ip_version",
    "docstring": "Returns the ip version (IPV4 or IPV6).\narg:\n    str_val (:tyep:`str`, `required):\n        The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n\nReturns:\n    int_val  (:type:`int128`, `required`):\n        The ip version (Either 4 or 6 for IPv4/IPv6)\n\nRaises:\n    netaddr.core.AddrFormatError (Exception):\n        Raised when the passed str_val is not a valid ip string value.",
    "parameters": [
      {
        "name": "str_val",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "ip__str__": {
    "name": "ip__str__",
    "docstring": "Return a formatted ip string",
    "parameters": [
      {
        "name": "ip_type",
        "type": "int"
      },
      {
        "name": "ip_str",
        "type": "str"
      },
      {
        "name": "port",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "get_external_ip": {
    "name": "get_external_ip",
    "docstring": "Checks CURL/URLLIB/IPIFY/AWS for your external ip.\nReturns:\n    external_ip  (:obj:`str` `required`):\n        Your routers external facing ip as a string.\n\nRaises:\n    ExternalIPNotFound (Exception):\n        Raised if all external ip attempts fail.",
    "parameters": [],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "get_formatted_ws_endpoint_url": {
    "name": "get_formatted_ws_endpoint_url",
    "docstring": "Returns a formatted websocket endpoint url.\nNote: The port (or lack thereof) is left unchanged\nArgs:\n    endpoint_url (str, `required`):\n        The endpoint url to format.\nReturns:\n    formatted_endpoint_url (str, `required`):\n        The formatted endpoint url. In the form of ws://<endpoint_url> or wss://<endpoint_url>",
    "parameters": [
      {
        "name": "endpoint_url",
        "type": "str"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/networking.py"
  },
  "_get_errors_from_pallet": {
    "name": "_get_errors_from_pallet",
    "docstring": "Extracts and returns error information from the given pallet metadata.\n\nArgs:\n    pallet (PalletMetadataV14): The pallet metadata containing error definitions.\n\nReturns:\n    dict[str, str]: A dictionary of errors indexed by their IDs.\n\nRaises:\n    ValueError: If the pallet does not contain error definitions or the list is empty.",
    "parameters": [
      {
        "name": "pallet",
        "type": null
      }
    ],
    "returns": "Optional[Dict[str, Dict[str, str]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/subtensor.py"
  },
  "_save_errors_to_cache": {
    "name": "_save_errors_to_cache",
    "docstring": "Saves error details and unique version identifier to a JSON file.\n\nArgs:\n    uniq_version (str): Unique version identifier for the Subtensor build.\n    errors (dict[str, str]): Error information to be cached.",
    "parameters": [
      {
        "name": "uniq_version",
        "type": "str"
      },
      {
        "name": "errors",
        "type": "Dict[str, Dict[str, str]]"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/subtensor.py"
  },
  "_get_errors_from_cache": {
    "name": "_get_errors_from_cache",
    "docstring": "Retrieves and returns the cached error information from a JSON file, if it exists.\n\nReturns:\n        A dictionary containing error information.",
    "parameters": [],
    "returns": "Optional[Dict[str, Dict[str, Dict[str, str]]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/subtensor.py"
  },
  "get_subtensor_errors": {
    "name": "get_subtensor_errors",
    "docstring": "Fetches or retrieves cached Subtensor error definitions using metadata.\n\nArgs:\n    substrate (SubstrateInterface): Instance of SubstrateInterface to access metadata.\n\nReturns:\n    dict[str, str]: A dictionary containing error information.",
    "parameters": [
      {
        "name": "substrate",
        "type": "SubstrateInterface"
      }
    ],
    "returns": "Union[Dict[str, Dict[str, str]], Dict[Any, Any]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/subtensor.py"
  },
  "_get_version_file_path": {
    "name": "_get_version_file_path",
    "docstring": null,
    "parameters": [],
    "returns": "Path",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "_get_version_from_file": {
    "name": "_get_version_from_file",
    "docstring": null,
    "parameters": [
      {
        "name": "version_file",
        "type": "Path"
      }
    ],
    "returns": "Optional[str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "_get_version_from_pypi": {
    "name": "_get_version_from_pypi",
    "docstring": null,
    "parameters": [
      {
        "name": "timeout",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "get_and_save_latest_version": {
    "name": "get_and_save_latest_version",
    "docstring": null,
    "parameters": [
      {
        "name": "timeout",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "check_version": {
    "name": "check_version",
    "docstring": "Check if the current version of Bittensor is up to date with the latest version on PyPi.\nRaises a VersionCheckError if the version check fails.",
    "parameters": [
      {
        "name": "timeout",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "version_checking": {
    "name": "version_checking",
    "docstring": "Deprecated, kept for backwards compatibility. Use check_version() instead.",
    "parameters": [
      {
        "name": "timeout",
        "type": "int"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/version.py"
  },
  "normalize_max_weight": {
    "name": "normalize_max_weight",
    "docstring": "Normalizes the tensor x so that sum(x) = 1 and the max value is not greater than the limit.\nArgs:\n    x (:obj:`np.float32`):\n        Tensor to be max_value normalized.\n    limit: float:\n        Max value after normalization.\nReturns:\n    y (:obj:`np.float32`):\n        Normalized x tensor.",
    "parameters": [
      {
        "name": "x",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor']"
      },
      {
        "name": "limit",
        "type": "float"
      }
    ],
    "returns": "Union[NDArray[np.float32], 'torch.FloatTensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "convert_weight_uids_and_vals_to_tensor": {
    "name": "convert_weight_uids_and_vals_to_tensor",
    "docstring": "Converts weights and uids from chain representation into a np.array (inverse operation from convert_weights_and_uids_for_emit)\nArgs:\n    n: int:\n        number of neurons on network.\n    uids (:obj:`List[int],`):\n        Tensor of uids as destinations for passed weights.\n    weights (:obj:`List[int],`):\n        Tensor of weights.\nReturns:\n    row_weights ( np.float32 or torch.FloatTensor ):\n        Converted row weights.",
    "parameters": [
      {
        "name": "n",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "weights",
        "type": "List[int]"
      }
    ],
    "returns": "Union[NDArray[np.float32], 'torch.FloatTensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "convert_root_weight_uids_and_vals_to_tensor": {
    "name": "convert_root_weight_uids_and_vals_to_tensor",
    "docstring": "Converts root weights and uids from chain representation into a np.array or torch FloatTensor (inverse operation from convert_weights_and_uids_for_emit)\nArgs:\n    n: int:\n        number of neurons on network.\n    uids (:obj:`List[int],`):\n        Tensor of uids as destinations for passed weights.\n    weights (:obj:`List[int],`):\n        Tensor of weights.\n    subnets (:obj:`List[int],`):\n        list of subnets on the network\nReturns:\n    row_weights ( np.float32 ):\n        Converted row weights.",
    "parameters": [
      {
        "name": "n",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "weights",
        "type": "List[int]"
      },
      {
        "name": "subnets",
        "type": "List[int]"
      }
    ],
    "returns": "Union[NDArray[np.float32], 'torch.FloatTensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "convert_bond_uids_and_vals_to_tensor": {
    "name": "convert_bond_uids_and_vals_to_tensor",
    "docstring": "Converts bond and uids from chain representation into a np.array.\nArgs:\n    n: int:\n        number of neurons on network.\n    uids (:obj:`List[int],`):\n        Tensor of uids as destinations for passed bonds.\n    bonds (:obj:`List[int],`):\n        Tensor of bonds.\nReturns:\n    row_bonds ( np.float32 ):\n        Converted row bonds.",
    "parameters": [
      {
        "name": "n",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "bonds",
        "type": "List[int]"
      }
    ],
    "returns": "Union[NDArray[np.int64], 'torch.LongTensor']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "convert_weights_and_uids_for_emit": {
    "name": "convert_weights_and_uids_for_emit",
    "docstring": "Converts weights into integer u32 representation that sum to MAX_INT_WEIGHT.\nArgs:\n    uids (:obj:`np.int64,`):\n        Tensor of uids as destinations for passed weights.\n    weights (:obj:`np.float32,`):\n        Tensor of weights.\nReturns:\n    weight_uids (List[int]):\n        Uids as a list.\n    weight_vals (List[int]):\n        Weights as a list.",
    "parameters": [
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], 'torch.LongTensor']"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor']"
      }
    ],
    "returns": "Tuple[List[int], List[int]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "process_weights_for_netuid": {
    "name": "process_weights_for_netuid",
    "docstring": null,
    "parameters": [
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], 'torch.Tensor']"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.Tensor']"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "metagraph",
        "type": "'bittensor.metagraph'"
      },
      {
        "name": "exclude_quantile",
        "type": "int"
      }
    ],
    "returns": "Union[Tuple['torch.Tensor', 'torch.FloatTensor'], Tuple[NDArray[np.int64], NDArray[np.float32]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "generate_weight_hash": {
    "name": "generate_weight_hash",
    "docstring": "Generate a valid commit hash from the provided weights.\n\nArgs:\n    address (str): The account identifier. Wallet ss58_address.\n    netuid (int): The network unique identifier.\n    uids (List[int]): The list of UIDs.\n    salt (List[int]): The salt to add to hash.\n    values (List[int]): The list of weight values.\n    version_key (int): The version key.\n\nReturns:\n    str: The generated commit hash.",
    "parameters": [
      {
        "name": "address",
        "type": "str"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "values",
        "type": "List[int]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "salt",
        "type": "List[int]"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/weight_utils.py"
  },
  "solve_cuda": {
    "name": "solve_cuda",
    "docstring": "Solves the PoW problem using CUDA.\nArgs:\n    nonce_start: int64\n        Starting nonce.\n    update_interval: int64\n        Number of nonces to solve before updating block information.\n    tpb: int\n        Threads per block.\n    block_and_hotkey_hash_bytes: bytes\n        Keccak(Bytes of the block hash + bytes of the hotkey) 64 bytes.\n    difficulty: int256\n        Difficulty of the PoW problem.\n    limit: int256\n        Upper limit of the nonce.\n    dev_id: int (default=0)\n        The CUDA device ID\nReturns:\n    Tuple[int64, bytes]\n        Tuple of the nonce and the seal corresponding to the solution.\n        Returns -1 for nonce if no solution is found.",
    "parameters": [
      {
        "name": "nonce_start",
        "type": "np.int64"
      },
      {
        "name": "update_interval",
        "type": "np.int64"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "block_and_hotkey_hash_bytes",
        "type": "bytes"
      },
      {
        "name": "difficulty",
        "type": "int"
      },
      {
        "name": "limit",
        "type": "int"
      },
      {
        "name": "dev_id",
        "type": "int"
      }
    ],
    "returns": "Tuple[np.int64, bytes]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "reset_cuda": {
    "name": "reset_cuda",
    "docstring": "Resets the CUDA environment.",
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "log_cuda_errors": {
    "name": "log_cuda_errors",
    "docstring": "Logs any CUDA errors.",
    "parameters": [],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/utils/_register_cuda.py"
  },
  "all_loggers": {
    "name": "all_loggers",
    "docstring": "Generator that yields all logger instances in the application.\n\nIterates through the logging root manager's logger dictionary and yields all active `Logger` instances. It skips\nplaceholders and other types that are not instances of `Logger`.\n\nYields:\n    logger (logging.Logger): An active logger instance.",
    "parameters": [],
    "returns": "Generator[logging.Logger, None, None]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/helpers.py"
  },
  "all_logger_names": {
    "name": "all_logger_names",
    "docstring": "Generate the names of all active loggers.\n\nThis function iterates through the logging root manager's logger dictionary and yields the names of all active\n`Logger` instances. It skips placeholders and other types that are not instances of `Logger`.\n\nYields:\n    name (str): The name of an active logger.",
    "parameters": [],
    "returns": "Generator[str, None, None]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/helpers.py"
  },
  "get_max_logger_name_length": {
    "name": "get_max_logger_name_length",
    "docstring": "Calculate and return the length of the longest logger name.\n\nThis function iterates through all active logger names and determines the length of the longest name.\n\nReturns:\n    max_length (int): The length of the longest logger name.",
    "parameters": [],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/helpers.py"
  },
  "_trace": {
    "name": "_trace",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "message",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/format.py"
  },
  "_success": {
    "name": "_success",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "message",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/format.py"
  },
  "formatTime": {
    "name": "formatTime",
    "docstring": "Override formatTime to add milliseconds.\n\nArgs:\n    record (logging.LogRecord): The log record.\n    datefmt (str, optional): The date format string.\n\nReturns:\n    s (str): The formatted time string with milliseconds.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "record",
        "type": null
      },
      {
        "name": "datefmt",
        "type": null
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/format.py"
  },
  "format": {
    "name": "format",
    "docstring": "Override format to center the level name.\n\nArgs:\n    record (logging.LogRecord): The log record.\n\nReturns:\n    formated record (str): The formatted log record.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "record",
        "type": null
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/format.py"
  },
  "set_trace": {
    "name": "set_trace",
    "docstring": "Sets Trace state.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "on",
        "type": "bool"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_configure_handlers": {
    "name": "_configure_handlers",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "config",
        "type": null
      }
    ],
    "returns": "list[stdlogging.Handler]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "get_config": {
    "name": "get_config",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "set_config": {
    "name": "set_config",
    "docstring": "Set config after initialization, if desired.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "config",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_create_and_start_listener": {
    "name": "_create_and_start_listener",
    "docstring": "A listener to receive and publish log records.\n\nThis listener receives records from a queue populated by the main bittensor logger, as well as 3rd party loggers",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "handlers",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "get_queue": {
    "name": "get_queue",
    "docstring": "Get the queue the QueueListener is publishing from.\n\nTo set up logging in a separate process, a QueueHandler must be added to all the desired loggers.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_initialize_bt_logger": {
    "name": "_initialize_bt_logger",
    "docstring": "Initialize logging for bittensor.\n\nSince the initial state is Default, logging level for the module logger is INFO, and all third-party loggers are\nsilenced. Subsequent state transitions will handle all logger outputs.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_deinitialize_bt_logger": {
    "name": "_deinitialize_bt_logger",
    "docstring": "Find the logger by name and remove the queue handler associated with it.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_create_file_handler": {
    "name": "_create_file_handler",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "logfile",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "register_primary_logger": {
    "name": "register_primary_logger",
    "docstring": "Register a logger as primary logger\n\nThis adds a logger to the _primary_loggers set to ensure\nit doesn't get disabled when disabling third-party loggers.\nA queue handler is also associated with it.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "deregister_primary_logger": {
    "name": "deregister_primary_logger",
    "docstring": "De-registers a primary logger\n\nThis function removes the logger from the _primary_loggers\nset and deinitializes its queue handler",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "enable_third_party_loggers": {
    "name": "enable_third_party_loggers",
    "docstring": "Enables logging for third-party loggers by adding a queue handler to each.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "disable_third_party_loggers": {
    "name": "disable_third_party_loggers",
    "docstring": "Disables logging for third-party loggers by removing all their handlers.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "_enable_file_logging": {
    "name": "_enable_file_logging",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "logfile",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_transition": {
    "name": "before_transition",
    "docstring": "Stops listener after transition.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "event",
        "type": null
      },
      {
        "name": "state",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_transition": {
    "name": "after_transition",
    "docstring": "Starts listener after transition.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "event",
        "type": null
      },
      {
        "name": "state",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_enable_default": {
    "name": "before_enable_default",
    "docstring": "Logs status before enable Default.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_enable_default": {
    "name": "after_enable_default",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_enable_trace": {
    "name": "before_enable_trace",
    "docstring": "Logs status before enable Trace.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_enable_trace": {
    "name": "after_enable_trace",
    "docstring": "Logs status after enable Trace.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_disable_trace": {
    "name": "before_disable_trace",
    "docstring": "Logs status before disable Trace.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_disable_trace": {
    "name": "after_disable_trace",
    "docstring": "Logs status after disable Trace.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_enable_debug": {
    "name": "before_enable_debug",
    "docstring": "Logs status before enable Debug.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_enable_debug": {
    "name": "after_enable_debug",
    "docstring": "Logs status after enable Debug.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_disable_debug": {
    "name": "before_disable_debug",
    "docstring": "Logs status before disable Debug.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "after_disable_debug": {
    "name": "after_disable_debug",
    "docstring": "Logs status after disable Debug.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "before_disable_logging": {
    "name": "before_disable_logging",
    "docstring": "Prepares the logging system for disabling.\n\nThis method performs the following actions:\n1. Logs an informational message indicating that logging is being disabled.\n2. Disables trace mode in the stream formatter.\n3. Sets the logging level to CRITICAL for all loggers.\n\nThis ensures that only critical messages will be logged after this method is called.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "__trace_on__": {
    "name": "__trace_on__",
    "docstring": "Checks if the current state is in \"Trace\" mode.\n\nReturns:\n    bool: True if the current state is \"Trace\", otherwise False.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "success": {
    "name": "success",
    "docstring": "Wraps success message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "warning": {
    "name": "warning",
    "docstring": "Wraps warning message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "critical": {
    "name": "critical",
    "docstring": "Wraps critical message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "exception": {
    "name": "exception",
    "docstring": "Wraps exception message with prefix and suffix.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "msg",
        "type": null
      },
      {
        "name": "prefix",
        "type": null
      },
      {
        "name": "suffix",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "on": {
    "name": "on",
    "docstring": "Enable default state.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "off": {
    "name": "off",
    "docstring": "Disables all states.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "set_debug": {
    "name": "set_debug",
    "docstring": "Sets Debug state.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "on",
        "type": "bool"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "get_level": {
    "name": "get_level",
    "docstring": "Returns Logging level.",
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "__call__": {
    "name": "__call__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "config",
        "type": "bittensor.config"
      },
      {
        "name": "debug",
        "type": "bool"
      },
      {
        "name": "trace",
        "type": "bool"
      },
      {
        "name": "record_log",
        "type": "bool"
      },
      {
        "name": "logging_dir",
        "type": "str"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/btlogging/loggingmachine.py"
  },
  "__setitem__": {
    "name": "__setitem__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "key",
        "type": null
      },
      {
        "name": "value",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "__iter__": {
    "name": "__iter__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "__len__": {
    "name": "__len__",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "reset": {
    "name": "reset",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "setup": {
    "name": "setup",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "create_subnet": {
    "name": "create_subnet",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "set_difficulty": {
    "name": "set_difficulty",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "difficulty",
        "type": "int"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_register_neuron": {
    "name": "_register_neuron",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey",
        "type": "str"
      },
      {
        "name": "coldkey",
        "type": "str"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_convert_to_balance": {
    "name": "_convert_to_balance",
    "docstring": null,
    "parameters": [
      {
        "name": "balance",
        "type": "Union['Balance', float, int]"
      }
    ],
    "returns": "'Balance'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "force_register_neuron": {
    "name": "force_register_neuron",
    "docstring": "Force register a neuron on the mock chain, returning the UID.",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey",
        "type": "str"
      },
      {
        "name": "coldkey",
        "type": "str"
      },
      {
        "name": "stake",
        "type": "Union['Balance', float, int]"
      },
      {
        "name": "balance",
        "type": "Union['Balance', float, int]"
      }
    ],
    "returns": "int",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "force_set_balance": {
    "name": "force_set_balance",
    "docstring": "Returns:\n    Tuple[bool, Optional[str]]: (success, err_msg)",
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "ss58_address",
        "type": "str"
      },
      {
        "name": "balance",
        "type": "Union['Balance', float, int]"
      }
    ],
    "returns": "Tuple[bool, Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "do_block_step": {
    "name": "do_block_step",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_handle_type_default": {
    "name": "_handle_type_default",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "params",
        "type": "List[object]"
      }
    ],
    "returns": "object",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_get_most_recent_storage": {
    "name": "_get_most_recent_storage",
    "docstring": null,
    "parameters": [
      {
        "name": "storage",
        "type": "Dict[BlockNumber, Any]"
      },
      {
        "name": "block_number",
        "type": "Optional[int]"
      }
    ],
    "returns": "Any",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_get_axon_info": {
    "name": "_get_axon_info",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "AxonInfoDict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_get_prometheus_info": {
    "name": "_get_prometheus_info",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "PrometheusInfoDict",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "_neuron_subnet_exists": {
    "name": "_neuron_subnet_exists",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "Optional[NeuronInfo]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "min_required_stake": {
    "name": "min_required_stake",
    "docstring": "As the minimum required stake may change, this method allows us to dynamically\nupdate the amount in the mock without updating the tests",
    "parameters": [],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "query_subnet_info": {
    "name": "query_subnet_info",
    "docstring": null,
    "parameters": [
      {
        "name": "name",
        "type": "str"
      }
    ],
    "returns": "Optional[object]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/subtensor_mock.py"
  },
  "get_mock_wallet": {
    "name": "get_mock_wallet",
    "docstring": null,
    "parameters": [
      {
        "name": "coldkey",
        "type": "'bittensor.Keypair'"
      },
      {
        "name": "hotkey",
        "type": "'bittensor.Keypair'"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "get_mock_keypair": {
    "name": "get_mock_keypair",
    "docstring": "Returns a mock keypair from a uid and optional test_name.\nIf test_name is not provided, the uid is the only seed.\nIf test_name is provided, the uid is hashed with the test_name to create a unique seed for the test.",
    "parameters": [
      {
        "name": "uid",
        "type": "int"
      },
      {
        "name": "test_name",
        "type": "Optional[str]"
      }
    ],
    "returns": "bittensor.Keypair",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "get_mock_hotkey": {
    "name": "get_mock_hotkey",
    "docstring": null,
    "parameters": [
      {
        "name": "uid",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "get_mock_coldkey": {
    "name": "get_mock_coldkey",
    "docstring": null,
    "parameters": [
      {
        "name": "uid",
        "type": "int"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/mock/wallet_mock.py"
  },
  "check_netuid_set": {
    "name": "check_netuid_set",
    "docstring": null,
    "parameters": [
      {
        "name": "config",
        "type": "'bittensor.config'"
      },
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "allow_none",
        "type": "bool"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "check_for_cuda_reg_config": {
    "name": "check_for_cuda_reg_config",
    "docstring": "Checks, when CUDA is available, if the user would like to register with their CUDA device.",
    "parameters": [
      {
        "name": "config",
        "type": "'bittensor.config'"
      }
    ],
    "returns": "None",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "get_hotkey_wallets_for_wallet": {
    "name": "get_hotkey_wallets_for_wallet",
    "docstring": null,
    "parameters": [
      {
        "name": "wallet",
        "type": null
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "get_coldkey_wallets_for_path": {
    "name": "get_coldkey_wallets_for_path",
    "docstring": null,
    "parameters": [
      {
        "name": "path",
        "type": "str"
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "get_all_wallets_for_path": {
    "name": "get_all_wallets_for_path",
    "docstring": null,
    "parameters": [
      {
        "name": "path",
        "type": "str"
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "filter_netuids_by_registered_hotkeys": {
    "name": "filter_netuids_by_registered_hotkeys",
    "docstring": null,
    "parameters": [
      {
        "name": "cli",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "netuids",
        "type": null
      },
      {
        "name": "all_hotkeys",
        "type": null
      }
    ],
    "returns": "List[int]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "normalize_hyperparameters": {
    "name": "normalize_hyperparameters",
    "docstring": "Normalizes the hyperparameters of a subnet.\n\nArgs:\n    subnet: The subnet hyperparameters object.\n\nReturns:\n    A list of tuples containing the parameter name, value, and normalized value.",
    "parameters": [
      {
        "name": "subnet",
        "type": "bittensor.SubnetHyperparameters"
      }
    ],
    "returns": "List[Tuple[str, str, str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "_get_delegates_details_from_github": {
    "name": "_get_delegates_details_from_github",
    "docstring": null,
    "parameters": [
      {
        "name": "requests_get",
        "type": null
      },
      {
        "name": "url",
        "type": "str"
      }
    ],
    "returns": "Dict[str, DelegatesDetails]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "get_delegates_details": {
    "name": "get_delegates_details",
    "docstring": null,
    "parameters": [
      {
        "name": "url",
        "type": "str"
      }
    ],
    "returns": "Optional[Dict[str, DelegatesDetails]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "check_choice": {
    "name": "check_choice",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "value",
        "type": "str"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "from_json": {
    "name": "from_json",
    "docstring": null,
    "parameters": [
      {
        "name": "cls",
        "type": null
      },
      {
        "name": "json",
        "type": "Dict[str, any]"
      }
    ],
    "returns": "'DelegatesDetails'",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/utils.py"
  },
  "_run": {
    "name": "_run",
    "docstring": null,
    "parameters": [
      {
        "name": "cli",
        "type": "'bittensor.cli'"
      },
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/identity.py"
  },
  "_get_total_balance": {
    "name": "_get_total_balance",
    "docstring": null,
    "parameters": [
      {
        "name": "total_balance",
        "type": "'bittensor.Balance'"
      },
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "cli",
        "type": "'bittensor.cli'"
      }
    ],
    "returns": "Tuple[List['bittensor.wallet'], 'bittensor.Balance']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_get_hotkeys": {
    "name": "_get_hotkeys",
    "docstring": null,
    "parameters": [
      {
        "name": "cli",
        "type": "'bittensor.cli'"
      },
      {
        "name": "all_hotkeys",
        "type": "List['bittensor.wallet']"
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_get_key_address": {
    "name": "_get_key_address",
    "docstring": null,
    "parameters": [
      {
        "name": "all_hotkeys",
        "type": "List['bittensor.wallet']"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_process_neuron_results": {
    "name": "_process_neuron_results",
    "docstring": null,
    "parameters": [
      {
        "name": "results",
        "type": "List[Tuple[int, List['bittensor.NeuronInfoLite'], Optional[str]]]"
      },
      {
        "name": "neurons",
        "type": "Dict[str, List['bittensor.NeuronInfoLite']]"
      },
      {
        "name": "netuids",
        "type": "List[int]"
      }
    ],
    "returns": "Dict[str, List['bittensor.NeuronInfoLite']]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_get_neurons_for_netuid": {
    "name": "_get_neurons_for_netuid",
    "docstring": null,
    "parameters": [
      {
        "name": "args_tuple",
        "type": "Tuple['bittensor.Config', int, List[str]]"
      }
    ],
    "returns": "Tuple[int, List['bittensor.NeuronInfoLite'], Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_get_de_registered_stake_for_coldkey_wallet": {
    "name": "_get_de_registered_stake_for_coldkey_wallet",
    "docstring": null,
    "parameters": [
      {
        "name": "args_tuple",
        "type": null
      }
    ],
    "returns": "Tuple['bittensor.Wallet', List[Tuple[str, 'bittensor.Balance']], Optional[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_filter_stake_info": {
    "name": "_filter_stake_info",
    "docstring": null,
    "parameters": [
      {
        "name": "stake_info",
        "type": "'bittensor.StakeInfo'"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "overview_sort_function": {
    "name": "overview_sort_function",
    "docstring": null,
    "parameters": [
      {
        "name": "row",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/overview.py"
  },
  "_get_coldkey_wallets_for_path": {
    "name": "_get_coldkey_wallets_for_path",
    "docstring": null,
    "parameters": [
      {
        "name": "path",
        "type": "str"
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "show_delegates_lite": {
    "name": "show_delegates_lite",
    "docstring": "This method is a lite version of the :func:`show_delegates`. This method displays a formatted table of Bittensor network delegates with detailed statistics to the console.\n\nThe table is sorted by total stake in descending order and provides\na snapshot of delegate performance and status, helping users make informed decisions for staking or nominating.\n\nThis helper function is not intended to be used directly in user code unless specifically required.\n\nArgs:\n    delegates_lite (List[bittensor.DelegateInfoLite]): A list of delegate information objects to be displayed.\n    width (Optional[int]): The width of the console output table. Defaults to ``None``, which will make the table expand to the maximum width of the console.\n\nThe output table contains the following columns. To display more columns, use the :func:`show_delegates` function.\n\n- INDEX: The numerical index of the delegate.\n- DELEGATE: The name of the delegate.\n- SS58: The truncated SS58 address of the delegate.\n- NOMINATORS: The number of nominators supporting the delegate.\n- VPERMIT: Validator permits held by the delegate for the subnets.\n- TAKE: The percentage of the delegate's earnings taken by the network.\n- DELEGATE/(24h): The earnings of the delegate in the last 24 hours.\n- Desc: A brief description provided by the delegate.\n\nUsage:\n    This function is typically used within the Bittensor CLI to show current delegate options to users who are considering where to stake their tokens.\n\nExample usage::\n\n    show_delegates_lite(delegates_lite, width=80)\n\nNote:\n    This function is primarily for display purposes within a command-line interface and does not return any values. It relies on the `rich <https://github.com/Textualize/rich>`_ Python library to render\n    the table in the console.",
    "parameters": [
      {
        "name": "delegates_lite",
        "type": "List['bittensor.DelegateInfoLite']"
      },
      {
        "name": "width",
        "type": "Optional[int]"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/delegates.py"
  },
  "show_delegates": {
    "name": "show_delegates",
    "docstring": "Displays a formatted table of Bittensor network delegates with detailed statistics to the console.\n\nThe table is sorted by total stake in descending order and provides\na snapshot of delegate performance and status, helping users make informed decisions for staking or nominating.\n\nThis is a helper function that is called by the :func:`list_delegates` and :func:`my_delegates`, and is not intended\nto be used directly in user code unless specifically required.\n\nArgs:\n    delegates (List[bittensor.DelegateInfo]): A list of delegate information objects to be displayed.\n    prev_delegates (Optional[List[bittensor.DelegateInfo]]): A list of delegate information objects from a previous state, used to calculate changes in stake. Defaults to ``None``.\n    width (Optional[int]): The width of the console output table. Defaults to ``None``, which will make the table expand to the maximum width of the console.\n\nThe output table contains the following columns:\n\n- INDEX: The numerical index of the delegate.\n- DELEGATE: The name of the delegate.\n- SS58: The truncated SS58 address of the delegate.\n- NOMINATORS: The number of nominators supporting the delegate.\n- DELEGATE STAKE(\u03c4): The stake that is directly delegated to the delegate.\n- TOTAL STAKE(\u03c4): The total stake held by the delegate, including nominators' stake.\n- CHANGE/(4h): The percentage change in the delegate's stake over the past 4 hours.\n- VPERMIT: Validator permits held by the delegate for the subnets.\n- TAKE: The percentage of the delegate's earnings taken by the network.\n- NOMINATOR/(24h)/k\u03c4: The earnings per 1000 \u03c4 staked by nominators in the last 24 hours.\n- DELEGATE/(24h): The earnings of the delegate in the last 24 hours.\n- Desc: A brief description provided by the delegate.\n\nUsage:\n    This function is typically used within the Bittensor CLI to show current delegate options to users who are considering where to stake their tokens.\n\nExample usage::\n\n    show_delegates(current_delegates, previous_delegates, width=80)\n\nNote:\n    This function is primarily for display purposes within a command-line interface and does\n    not return any values. It relies on the `rich <https://github.com/Textualize/rich>`_ Python library to render\n    the table in the\n    console.",
    "parameters": [
      {
        "name": "delegates",
        "type": "List['bittensor.DelegateInfo']"
      },
      {
        "name": "prev_delegates",
        "type": "Optional[List['bittensor.DelegateInfo']]"
      },
      {
        "name": "width",
        "type": "Optional[int]"
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/delegates.py"
  },
  "fetch_arbitration_stats": {
    "name": "fetch_arbitration_stats",
    "docstring": "Performs a check of the current arbitration data (if any), and displays it through the bittensor console.",
    "parameters": [
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "wallet",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/check_coldkey_swap.py"
  },
  "allowed_value": {
    "name": "allowed_value",
    "docstring": "Check the allowed values on hyperparameters. Return False if value is out of bounds.",
    "parameters": [
      {
        "name": "param",
        "type": "str"
      },
      {
        "name": "value",
        "type": "Union[str, bool, float]"
      }
    ],
    "returns": "Tuple[bool, Union[str, list[float], float]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/network.py"
  },
  "_get_coldkey_ss58_addresses_for_path": {
    "name": "_get_coldkey_ss58_addresses_for_path",
    "docstring": "Get all coldkey ss58 addresses from path.",
    "parameters": [
      {
        "name": "path",
        "type": "str"
      }
    ],
    "returns": "Tuple[List[str], List[str]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/wallets.py"
  },
  "get_wallet_transfers": {
    "name": "get_wallet_transfers",
    "docstring": "Get all transfers associated with the provided wallet address.",
    "parameters": [
      {
        "name": "wallet_address",
        "type": null
      }
    ],
    "returns": "List[dict]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/wallets.py"
  },
  "create_transfer_history_table": {
    "name": "create_transfer_history_table",
    "docstring": "Get output transfer table",
    "parameters": [
      {
        "name": "transfers",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/wallets.py"
  },
  "list_coldkeypub_files": {
    "name": "list_coldkeypub_files",
    "docstring": null,
    "parameters": [
      {
        "name": "dir_path",
        "type": null
      }
    ],
    "returns": null,
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/wallets.py"
  },
  "_get_hotkey_wallets_for_wallet": {
    "name": "_get_hotkey_wallets_for_wallet",
    "docstring": null,
    "parameters": [
      {
        "name": "wallet",
        "type": null
      }
    ],
    "returns": "List['bittensor.wallet']",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "format_call_data": {
    "name": "format_call_data",
    "docstring": null,
    "parameters": [
      {
        "name": "call_data",
        "type": "'bittensor.ProposalCallData'"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/senate.py"
  },
  "display_votes": {
    "name": "display_votes",
    "docstring": null,
    "parameters": [
      {
        "name": "vote_data",
        "type": "'bittensor.ProposalVoteData'"
      },
      {
        "name": "delegate_info",
        "type": "'bittensor.DelegateInfo'"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/senate.py"
  },
  "get_stake_accounts": {
    "name": "get_stake_accounts",
    "docstring": "Get stake account details for the given wallet.\n\nArgs:\n    wallet: The wallet object to fetch the stake account details for.\n\nReturns:\n    A dictionary mapping SS58 addresses to their respective stake account details.",
    "parameters": [
      {
        "name": "wallet",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      }
    ],
    "returns": "Dict[str, Dict[str, Union[str, Balance]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "get_stakes_from_hotkeys": {
    "name": "get_stakes_from_hotkeys",
    "docstring": "Fetch stakes from hotkeys for the provided wallet.\n\nArgs:\n    wallet: The wallet object to fetch the stakes for.\n\nReturns:\n    A dictionary of stakes related to hotkeys.",
    "parameters": [
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "wallet",
        "type": null
      }
    ],
    "returns": "Dict[str, Dict[str, Union[str, Balance]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "get_stakes_from_delegates": {
    "name": "get_stakes_from_delegates",
    "docstring": "Fetch stakes from delegates for the provided wallet.\n\nArgs:\n    wallet: The wallet object to fetch the stakes for.\n\nReturns:\n    A dictionary of stakes related to delegates.",
    "parameters": [
      {
        "name": "subtensor",
        "type": null
      },
      {
        "name": "wallet",
        "type": null
      }
    ],
    "returns": "Dict[str, Dict[str, Union[str, Balance]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "get_all_wallet_accounts": {
    "name": "get_all_wallet_accounts",
    "docstring": "Fetch stake accounts for all provided wallets using a ThreadPool.\n\nArgs:\n    wallets: List of wallets to fetch the stake accounts for.\n\nReturns:\n    A list of dictionaries, each dictionary containing stake account details for each wallet.",
    "parameters": [
      {
        "name": "wallets",
        "type": null
      },
      {
        "name": "subtensor",
        "type": null
      }
    ],
    "returns": "List[Dict[str, Dict[str, Union[str, Balance]]]]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/commands/stake.py"
  },
  "transfer_extrinsic": {
    "name": "transfer_extrinsic",
    "docstring": "Transfers funds from this wallet to the destination public key address.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object to make transfer from.\n    dest (str, ss58_address or ed25519):\n        Destination public key address of reciever.\n    amount (Union[Balance, int]):\n        Amount to stake as Bittensor balance, or ``float`` interpreted as Tao.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    keep_alive (bool):\n        If set, keeps the account alive by keeping the balance above the existential deposit.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "dest",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "Union[Balance, float]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "keep_alive",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/transfer.py"
  },
  "commit_weights_extrinsic": {
    "name": "commit_weights_extrinsic",
    "docstring": "Commits a hash of the neuron's weights to the Bittensor blockchain using the provided wallet.\nThis function is a wrapper around the `_do_commit_weights` method, handling user prompts and error messages.\nArgs:\n    subtensor (bittensor.subtensor): The subtensor instance used for blockchain interaction.\n    wallet (bittensor.wallet): The wallet associated with the neuron committing the weights.\n    netuid (int): The unique identifier of the subnet.\n    commit_hash (str): The hash of the neuron's weights to be committed.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\nReturns:\n    Tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string\n    value describing the success or potential error.\nThis function provides a user-friendly interface for committing weights to the Bittensor blockchain, ensuring proper\nerror handling and user interaction when required.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "commit_hash",
        "type": "str"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/commit_weights.py"
  },
  "reveal_weights_extrinsic": {
    "name": "reveal_weights_extrinsic",
    "docstring": "Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.\nThis function is a wrapper around the `_do_reveal_weights` method, handling user prompts and error messages.\nArgs:\n    subtensor (bittensor.subtensor): The subtensor instance used for blockchain interaction.\n    wallet (bittensor.wallet): The wallet associated with the neuron revealing the weights.\n    netuid (int): The unique identifier of the subnet.\n    uids (List[int]): List of neuron UIDs for which weights are being revealed.\n    weights (List[int]): List of weight values corresponding to each UID.\n    salt (List[int]): List of salt values corresponding to the hash function.\n    version_key (int): Version key for compatibility with the network.\n    wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.\n    wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.\n    prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.\nReturns:\n    Tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string\n    value describing the success or potential error.\nThis function provides a user-friendly interface for revealing weights on the Bittensor blockchain, ensuring proper\nerror handling and user interaction when required.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "List[int]"
      },
      {
        "name": "weights",
        "type": "List[int]"
      },
      {
        "name": "salt",
        "type": "List[int]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/commit_weights.py"
  },
  "_check_threshold_amount": {
    "name": "_check_threshold_amount",
    "docstring": "Checks if the new stake balance will be above the minimum required stake threshold.\n\nArgs:\n    stake_balance (Balance):\n        the balance to check for threshold limits.\n\nReturns:\n    success, threshold (bool, Balance):\n        ``true`` if the staking balance is above the threshold, or ``false`` if the\n            staking balance is below the threshold.\n        The threshold balance required to stake.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "stake_balance",
        "type": "Balance"
      }
    ],
    "returns": "Tuple[bool, Balance]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/staking.py"
  },
  "add_stake_extrinsic": {
    "name": "add_stake_extrinsic",
    "docstring": "Adds the specified amount of stake to passed hotkey ``uid``.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (Optional[str]):\n        The ``ss58`` address of the hotkey account to stake to defaults to the wallet's hotkey.\n    amount (Union[Balance, float]):\n        Amount to stake as Bittensor balance, or ``float`` interpreted as Tao.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.\n\nRaises:\n    bittensor.errors.NotRegisteredError:\n        If the wallet is not registered on the chain.\n    bittensor.errors.NotDelegateError:\n        If the hotkey is not a delegate on the chain.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/staking.py"
  },
  "add_stake_multiple_extrinsic": {
    "name": "add_stake_multiple_extrinsic",
    "docstring": "Adds stake to each ``hotkey_ss58`` in the list, using each amount, from a common coldkey.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object for the coldkey.\n    hotkey_ss58s (List[str]):\n        List of hotkeys to stake to.\n    amounts (List[Union[Balance, float]]):\n        List of amounts to stake. If ``None``, stake all to the first hotkey.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block. Flag is ``true`` if any wallet was staked. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58s",
        "type": "List[str]"
      },
      {
        "name": "amounts",
        "type": "Optional[List[Union[Balance, float]]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/staking.py"
  },
  "__do_add_stake_single": {
    "name": "__do_add_stake_single",
    "docstring": "Executes a stake call to the chain using the wallet and the amount specified.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (str):\n        Hotkey to stake to.\n    amount (bittensor.Balance):\n        Amount to stake as Bittensor balance object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.\nRaises:\n    bittensor.errors.StakeError:\n        If the extrinsic fails to be finalized or included in the block.\n    bittensor.errors.NotDelegateError:\n        If the hotkey is not a delegate.\n    bittensor.errors.NotRegisteredError:\n        If the hotkey is not registered in any subnets.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'bittensor.Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/staking.py"
  },
  "__do_remove_stake_single": {
    "name": "__do_remove_stake_single",
    "docstring": "Executes an unstake call to the chain using the wallet and the amount specified.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (str):\n        Hotkey address to unstake from.\n    amount (bittensor.Balance):\n        Amount to unstake as Bittensor balance object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.\nRaises:\n    bittensor.errors.StakeError:\n        If the extrinsic fails to be finalized or included in the block.\n    bittensor.errors.NotRegisteredError:\n        If the hotkey is not registered in any subnets.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "str"
      },
      {
        "name": "amount",
        "type": "'bittensor.Balance'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/unstaking.py"
  },
  "check_threshold_amount": {
    "name": "check_threshold_amount",
    "docstring": "Checks if the remaining stake balance is above the minimum required stake threshold.\n\nArgs:\n    stake_balance (Balance):\n        the balance to check for threshold limits.\n\nReturns:\n    success (bool):\n        ``true`` if the unstaking is above the threshold or 0, or ``false`` if the\n            unstaking is below the threshold, but not 0.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "stake_balance",
        "type": "Balance"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/unstaking.py"
  },
  "unstake_extrinsic": {
    "name": "unstake_extrinsic",
    "docstring": "Removes stake into the wallet coldkey from the specified hotkey ``uid``.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (Optional[str]):\n        The ``ss58`` address of the hotkey to unstake from. By default, the wallet hotkey is used.\n    amount (Union[Balance, float]):\n        Amount to stake as Bittensor balance, or ``float`` interpreted as Tao.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/unstaking.py"
  },
  "unstake_multiple_extrinsic": {
    "name": "unstake_multiple_extrinsic",
    "docstring": "Removes stake from each ``hotkey_ss58`` in the list, using each amount, to a common coldkey.\n\nArgs:\n    wallet (bittensor.wallet):\n        The wallet with the coldkey to unstake to.\n    hotkey_ss58s (List[str]):\n        List of hotkeys to unstake from.\n    amounts (List[Union[Balance, float]]):\n        List of amounts to unstake. If ``None``, unstake all.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block. Flag is ``true`` if any wallet was unstaked. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58s",
        "type": "List[str]"
      },
      {
        "name": "amounts",
        "type": "Optional[List[Union[Balance, float]]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/unstaking.py"
  },
  "register_extrinsic": {
    "name": "register_extrinsic",
    "docstring": "Registers the wallet to the chain.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    netuid (int):\n        The ``netuid`` of the subnet to register on.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\n    max_allowed_attempts (int):\n        Maximum number of attempts to register the wallet.\n    cuda (bool):\n        If ``true``, the wallet should be registered using CUDA device(s).\n    dev_id (Union[List[int], int]):\n        The CUDA device id to use, or a list of device ids.\n    tpb (int):\n        The number of threads per block (CUDA).\n    num_processes (int):\n        The number of processes to use to register.\n    update_interval (int):\n        The number of nonces to solve between updates.\n    log_verbose (bool):\n        If ``true``, the registration process will log more information.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_allowed_attempts",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "cuda",
        "type": "bool"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "num_processes",
        "type": "Optional[int]"
      },
      {
        "name": "update_interval",
        "type": "Optional[int]"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/registration.py"
  },
  "burned_register_extrinsic": {
    "name": "burned_register_extrinsic",
    "docstring": "Registers the wallet to chain by recycling TAO.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    netuid (int):\n        The ``netuid`` of the subnet to register on.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/registration.py"
  },
  "run_faucet_extrinsic": {
    "name": "run_faucet_extrinsic",
    "docstring": "Runs a continual POW to get a faucet of TAO on the test net.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    max_allowed_attempts (int):\n        Maximum number of attempts to register the wallet.\n    cuda (bool):\n        If ``true``, the wallet should be registered using CUDA device(s).\n    dev_id (Union[List[int], int]):\n        The CUDA device id to use, or a list of device ids.\n    tpb (int):\n        The number of threads per block (CUDA).\n    num_processes (int):\n        The number of processes to use to register.\n    update_interval (int):\n        The number of nonces to solve between updates.\n    log_verbose (bool):\n        If ``true``, the registration process will log more information.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      },
      {
        "name": "max_allowed_attempts",
        "type": "int"
      },
      {
        "name": "output_in_place",
        "type": "bool"
      },
      {
        "name": "cuda",
        "type": "bool"
      },
      {
        "name": "dev_id",
        "type": "Union[List[int], int]"
      },
      {
        "name": "tpb",
        "type": "int"
      },
      {
        "name": "num_processes",
        "type": "Optional[int]"
      },
      {
        "name": "update_interval",
        "type": "Optional[int]"
      },
      {
        "name": "log_verbose",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/registration.py"
  },
  "swap_hotkey_extrinsic": {
    "name": "swap_hotkey_extrinsic",
    "docstring": null,
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "new_wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/registration.py"
  },
  "_find_event_attributes_in_extrinsic_receipt": {
    "name": "_find_event_attributes_in_extrinsic_receipt",
    "docstring": "Searches for the attributes of a specified event within an extrinsic receipt.\n\nArgs:\n    response (substrateinterface.base.ExtrinsicReceipt): The receipt of the extrinsic to be searched.\n    event_name (str): The name of the event to search for.\n\nReturns:\n    list: A list of attributes for the specified event. Returns [-1] if the event is not found.",
    "parameters": [
      {
        "name": "response",
        "type": "'substrateinterface.base.ExtrinsicReceipt'"
      },
      {
        "name": "event_name",
        "type": "str"
      }
    ],
    "returns": "list",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/network.py"
  },
  "register_subnetwork_extrinsic": {
    "name": "register_subnetwork_extrinsic",
    "docstring": "Registers a new subnetwork.\n\nArgs:\n    wallet (bittensor.wallet):\n        bittensor wallet object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If true, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block.\n        If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/network.py"
  },
  "set_hyperparameter_extrinsic": {
    "name": "set_hyperparameter_extrinsic",
    "docstring": "Sets a hyperparameter for a specific subnetwork.\n\nArgs:\n    wallet (bittensor.wallet):\n        bittensor wallet object.\n    netuid (int):\n        Subnetwork ``uid``.\n    parameter (str):\n        Hyperparameter name.\n    value (any):\n        New hyperparameter value.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block.\n        If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "parameter",
        "type": "str"
      },
      {
        "name": "value",
        "type": null
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/network.py"
  },
  "serve_extrinsic": {
    "name": "serve_extrinsic",
    "docstring": "Subscribes a Bittensor endpoint to the subtensor chain.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    ip (str):\n        Endpoint host port i.e., ``192.122.31.4``.\n    port (int):\n        Endpoint port number i.e., ``9221``.\n    protocol (int):\n        An ``int`` representation of the protocol.\n    netuid (int):\n        The network uid to serve on.\n    placeholder1 (int):\n        A placeholder for future use.\n    placeholder2 (int):\n        A placeholder for future use.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "ip",
        "type": "str"
      },
      {
        "name": "port",
        "type": "int"
      },
      {
        "name": "protocol",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "placeholder1",
        "type": "int"
      },
      {
        "name": "placeholder2",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": null
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/serving.py"
  },
  "serve_axon_extrinsic": {
    "name": "serve_axon_extrinsic",
    "docstring": "Serves the axon to the network.\n\nArgs:\n    netuid ( int ):\n        The ``netuid`` being served on.\n    axon (bittensor.Axon):\n        Axon to serve.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "axon",
        "type": "'bittensor.Axon'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/serving.py"
  },
  "publish_metadata": {
    "name": "publish_metadata",
    "docstring": "Publishes metadata on the Bittensor network using the specified wallet and network identifier.\n\nArgs:\n    subtensor (bittensor.subtensor):\n        The subtensor instance representing the Bittensor blockchain connection.\n    wallet (bittensor.wallet):\n        The wallet object used for authentication in the transaction.\n    netuid (int):\n        Network UID on which the metadata is to be published.\n    data_type (str):\n        The data type of the information being submitted. It should be one of the following: ``'Sha256'``, ``'Blake256'``, ``'Keccak256'``, or ``'Raw0-128'``. This specifies the format or hashing algorithm used for the data.\n    data (str):\n        The actual metadata content to be published. This should be formatted or hashed according to the ``type`` specified. (Note: max ``str`` length is 128 bytes)\n    wait_for_inclusion (bool, optional):\n        If ``True``, the function will wait for the extrinsic to be included in a block before returning. Defaults to ``False``.\n    wait_for_finalization (bool, optional):\n        If ``True``, the function will wait for the extrinsic to be finalized on the chain before returning. Defaults to ``True``.\n\nReturns:\n    bool:\n        ``True`` if the metadata was successfully published (and finalized if specified). ``False`` otherwise.\n\nRaises:\n    MetadataError:\n        If there is an error in submitting the extrinsic or if the response from the blockchain indicates failure.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "data_type",
        "type": "str"
      },
      {
        "name": "data",
        "type": "bytes"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/serving.py"
  },
  "get_metadata": {
    "name": "get_metadata",
    "docstring": null,
    "parameters": [
      {
        "name": "self",
        "type": null
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "hotkey",
        "type": "str"
      },
      {
        "name": "block",
        "type": "Optional[int]"
      }
    ],
    "returns": "str",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/serving.py"
  },
  "register_senate_extrinsic": {
    "name": "register_senate_extrinsic",
    "docstring": "Registers the wallet to chain for senate voting.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/senate.py"
  },
  "leave_senate_extrinsic": {
    "name": "leave_senate_extrinsic",
    "docstring": "Removes the wallet from chain for senate voting.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/senate.py"
  },
  "vote_senate_extrinsic": {
    "name": "vote_senate_extrinsic",
    "docstring": "Votes ayes or nays on proposals.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or included in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "proposal_hash",
        "type": "str"
      },
      {
        "name": "proposal_idx",
        "type": "int"
      },
      {
        "name": "vote",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/senate.py"
  },
  "prometheus_extrinsic": {
    "name": "prometheus_extrinsic",
    "docstring": "Subscribes an Bittensor endpoint to the substensor chain.\n\nArgs:\n    subtensor (bittensor.subtensor):\n        Bittensor subtensor object.\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    ip (str):\n        Endpoint host port i.e., ``192.122.31.4``.\n    port (int):\n        Endpoint port number i.e., `9221`.\n    netuid (int):\n        Network `uid` to serve on.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block.\n        If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "port",
        "type": "int"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "ip",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": null
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/prometheus.py"
  },
  "set_weights_extrinsic": {
    "name": "set_weights_extrinsic",
    "docstring": "Sets the given weights and values on chain for wallet hotkey account.\n\nArgs:\n    subtensor (bittensor.subtensor):\n        Subtensor endpoint to use.\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    netuid (int):\n        The ``netuid`` of the subnet to set weights for.\n    uids (Union[NDArray[np.int64], torch.LongTensor, list]):\n        The ``uint64`` uids of destination neurons.\n    weights (Union[NDArray[np.float32], torch.FloatTensor, list]):\n        The weights to set. These must be ``float`` s and correspond to the passed ``uid`` s.\n    version_key (int):\n        The version key of the validator.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuid",
        "type": "int"
      },
      {
        "name": "uids",
        "type": "Union[NDArray[np.int64], 'torch.LongTensor', list]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor', list]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "Tuple[bool, str]",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/set_weights.py"
  },
  "nominate_extrinsic": {
    "name": "nominate_extrinsic",
    "docstring": "Becomes a delegate for the hotkey.\n\nArgs:\n    wallet (bittensor.wallet): The wallet to become a delegate for.\nReturns:\n    success (bool): ``True`` if the transaction was successful.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/delegation.py"
  },
  "delegate_extrinsic": {
    "name": "delegate_extrinsic",
    "docstring": "Delegates the specified amount of stake to the passed delegate.\n\nArgs:\n    wallet (bittensor.wallet): Bittensor wallet object.\n    delegate_ss58 (Optional[str]): The ``ss58`` address of the delegate.\n    amount (Union[Balance, float]): Amount to stake as bittensor balance, or ``float`` interpreted as Tao.\n    wait_for_inclusion (bool): If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool): If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool): If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool): Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.\n\nRaises:\n    NotRegisteredError: If the wallet is not registered on the chain.\n    NotDelegateError: If the hotkey is not a delegate on the chain.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/delegation.py"
  },
  "undelegate_extrinsic": {
    "name": "undelegate_extrinsic",
    "docstring": "Un-delegates stake from the passed delegate.\n\nArgs:\n    wallet (bittensor.wallet): Bittensor wallet object.\n    delegate_ss58 (Optional[str]): The ``ss58`` address of the delegate.\n    amount (Union[Balance, float]): Amount to unstake as bittensor balance, or ``float`` interpreted as Tao.\n    wait_for_inclusion (bool): If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool): If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool): If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool): Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.\n\nRaises:\n    NotRegisteredError: If the wallet is not registered on the chain.\n    NotDelegateError: If the hotkey is not a delegate on the chain.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "delegate_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "amount",
        "type": "Optional[Union[Balance, float]]"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/delegation.py"
  },
  "decrease_take_extrinsic": {
    "name": "decrease_take_extrinsic",
    "docstring": "Decrease delegate take for the hotkey.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (Optional[str]):\n        The ``ss58`` address of the hotkey account to stake to defaults to the wallet's hotkey.\n    take (float):\n        The ``take`` of the hotkey.\nReturns:\n    success (bool): ``True`` if the transaction was successful.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "take",
        "type": "int"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/delegation.py"
  },
  "increase_take_extrinsic": {
    "name": "increase_take_extrinsic",
    "docstring": "Increase delegate take for the hotkey.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    hotkey_ss58 (Optional[str]):\n        The ``ss58`` address of the hotkey account to stake to defaults to the wallet's hotkey.\n    take (float):\n        The ``take`` of the hotkey.\nReturns:\n    success (bool): ``True`` if the transaction was successful.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "hotkey_ss58",
        "type": "Optional[str]"
      },
      {
        "name": "take",
        "type": "int"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/delegation.py"
  },
  "root_register_extrinsic": {
    "name": "root_register_extrinsic",
    "docstring": "Registers the wallet to root network.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/root.py"
  },
  "set_root_weights_extrinsic": {
    "name": "set_root_weights_extrinsic",
    "docstring": "Sets the given weights and values on chain for wallet hotkey account.\n\nArgs:\n    wallet (bittensor.wallet):\n        Bittensor wallet object.\n    netuids (Union[NDArray[np.int64], torch.LongTensor, List[int]]):\n        The ``netuid`` of the subnet to set weights for.\n    weights (Union[NDArray[np.float32], torch.FloatTensor, list]):\n        Weights to set. These must be ``float`` s and must correspond to the passed ``netuid`` s.\n    version_key (int):\n        The version key of the validator.\n    wait_for_inclusion (bool):\n        If set, waits for the extrinsic to enter a block before returning ``true``, or returns ``false`` if the extrinsic fails to enter the block within the timeout.\n    wait_for_finalization (bool):\n        If set, waits for the extrinsic to be finalized on the chain before returning ``true``, or returns ``false`` if the extrinsic fails to be finalized within the timeout.\n    prompt (bool):\n        If ``true``, the call waits for confirmation from the user before proceeding.\nReturns:\n    success (bool):\n        Flag is ``true`` if extrinsic was finalized or uncluded in the block. If we did not wait for finalization / inclusion, the response is ``true``.",
    "parameters": [
      {
        "name": "subtensor",
        "type": "'bittensor.subtensor'"
      },
      {
        "name": "wallet",
        "type": "'bittensor.wallet'"
      },
      {
        "name": "netuids",
        "type": "Union[NDArray[np.int64], 'torch.LongTensor', List[int]]"
      },
      {
        "name": "weights",
        "type": "Union[NDArray[np.float32], 'torch.FloatTensor', List[float]]"
      },
      {
        "name": "version_key",
        "type": "int"
      },
      {
        "name": "wait_for_inclusion",
        "type": "bool"
      },
      {
        "name": "wait_for_finalization",
        "type": "bool"
      },
      {
        "name": "prompt",
        "type": "bool"
      }
    ],
    "returns": "bool",
    "file_path": ".venv/lib/python3.10/site-packages/bittensor/extrinsics/root.py"
  }
}